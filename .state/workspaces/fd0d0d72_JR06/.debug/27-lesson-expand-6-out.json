{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "serialized-format-layout",
    "type": "concept",
    "content": "A structured clone payload is a concatenation of tagged records, each starting with a 32-bit little-endian tag ID followed by a 32-bit length field describing the bytes that immediately follow. Containers (objects/arrays) store their child count first, then inlined child records; primitives store a byte span; transferables reserve space for bookkeeping. ArrayBuffer records therefore look like `[TAG_ARRAYBUFFER | byte_length | raw bytes]`, and the clone arena copies the backing store once before the writer advances the cursor. SharedArrayBuffers diverge right after the tag: instead of raw bytes, the writer emits a handle descriptor `[handle fd | shared_length | flags]`, because SAB ownership is shared, not copied. MessagePorts are similar but encode an entanglement slot plus endpoint IDs.\n```c\n#define TAG_ARRAYBUFFER        0x20u\n#define TAG_SHARED_ARRAYBUFFER 0x21u\n\nstatic int write_buffer_record(struct sc_encoded_buffer *out,\n                               uint32_t tag, const void *data,\n                               uint32_t length)\n{\n    uint32_t header[2] = { tag, length };\n    if (buffer_write(out, header, sizeof(header)))\n        return -EMSGSIZE;\n    if (data && buffer_write(out, data, length))\n        return -EMSGSIZE;\n    return 0;\n}\n\nint sc_encode_sab(struct sc_encoded_buffer *out,\n                  const struct sab_desc *sab)\n{\n    struct sab_record rec = {\n        .handle = sab->os_handle,\n        .length = sab->byte_length,\n        .flags = sab->has_atomics ? SAB_FLAG_HAS_ATOMICS : 0\n    };\n    return write_buffer_record(out, TAG_SHARED_ARRAYBUFFER,\n                               &rec, sizeof(rec));\n}\n```\nBecause SABs only stream metadata, their records stay fixed-width regardless of payload size, letting decoders remap handles lazily while ArrayBuffer records scale with every byte copied. This distinction keeps move-only resources from touching the wire while still allowing deep copies for regular buffers.",
    "is_complete": false,
    "next_focus": "Compare structured clone semantics to JSON.stringify and custom serializers, focusing on deep copy vs move semantics, fidelity, and performance cost."
  }
}