{
  "accepted": true,
  "schemaName": "starter_section_v1",
  "payload": {
    "schema_version": "starter_section_v1",
    "role": "starter-expand",
    "section_id": "structured-clone-executor-h",
    "type": "code",
    "file_path": "structured_clone_executor.h",
    "content": "#ifndef STRUCTURED_CLONE_EXECUTOR_H\n#define STRUCTURED_CLONE_EXECUTOR_H\n\n#include <stddef.h>\n#include \"structured_clone_context.h\"\n#include \"structured_clone_encoder.h\"\n\nstruct sc_worker_endpoint {\n    int queue_fd;\n    int signal_fd;\n    unsigned int flags;\n};\n\n/* Dispatch the encoded payload to a worker so the learner must marshal the IPC frame, signal readiness to the worker loop, and propagate transport errors from the runtime. */\nint sc_dispatch_to_worker(struct sc_context *ctx,\n                          struct sc_worker_endpoint *target,\n                          const struct sc_encoded_buffer *payload);\n\n/* Transfer ownership of MessagePort instances so the learner must validate entanglement pairs, reject duplicates with -EBUSY, and close sender endpoints when transfers succeed. */\nint sc_transfer_ports(struct sc_context *ctx,\n                      struct sc_transferable_desc *ports,\n                      size_t port_count);\n\n/* Commit the transfer list so the learner must detach buffers, update handle tables atomically, and roll back state when any finalization step fails mid-commit. */\nint sc_commit_transfer_list(struct sc_context *ctx,\n                            const struct sc_message_record *record);\n\n#endif /* STRUCTURED_CLONE_EXECUTOR_H */\n",
    "is_complete": true,
    "next_focus": ""
  }
}