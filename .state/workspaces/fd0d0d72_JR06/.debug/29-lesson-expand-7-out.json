{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "structured-clone-vs-json",
    "type": "comparison",
    "content": "JSON.stringify is a lossy, tree-only format: everything becomes UTF-8 text, prototypes collapse to plain objects, and transferables turn into either base64 blobs or implicit globals. Structured clone keeps native fidelity by recording tags per node, so TypedArrays, Maps, cyclic graphs, and MessagePorts maintain shape while still allowing deep copies or ownership moves. Performance-wise, JSON forces a fresh heap allocation for the string plus a regex-grade parser on the receiving side, whereas structured clone writes directly into a pre-sized arena and can mark certain resources as moved instead of copied (SharedArrayBuffers, ports). The difference shows up even in C glue code:\n```c\nint send_json(int fd, const struct js_value *value)\n{\n    char json[4096];\n    size_t len = js_stringify(value, json, sizeof(json));\n    return write(fd, json, len) == (ssize_t)len ? 0 : -EIO;\n}\n\nint send_clone(struct sc_context *ctx, const struct sc_value *value, int fd)\n{\n    struct sc_encoded_buffer buf = { .data = arena_base(ctx), .capacity = arena_size(ctx) };\n    if (sc_encode_value(ctx, value, &buf))\n        return -EINVAL;\n    return write(fd, buf.data, buf.length) == (ssize_t)buf.length ? 0 : -EIO;\n}\n```\nCustom serializers often mimic the first function: fast to sketch, but brittle when new node types appear. Structured clone behaves more like Rust’s `serde` with borrowing modes or Zig’s std.json parser paired with `ArenaAllocator`; you can mix deep copies and zero-copy moves depending on tag semantics without rewriting every consumer. That balance between fidelity and controlled performance cost is why browsers standardize the clone path instead of letting each subsystem invent bespoke JSON shims.",
    "is_complete": false,
    "next_focus": "Expose common pitfalls: non-cloneable objects, detached buffers, cyclic prototypes, and undefined behaviour when engine hooks skip slot sealing."
  }
}