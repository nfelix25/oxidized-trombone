{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "structured-clone-pitfalls",
    "type": "pitfalls",
    "content": "Four patterns regularly destabilize structured clone pipelines: (1) non-cloneable inputs (functions, DOM nodes, opaque host wrappers) that should trigger -EINVAL but instead leak through; (2) ArrayBuffers that the engine forgets to mark detached, so JS keeps writing into freed memory; (3) cyclic prototype chains that never re-enter the identity table, causing exponential re-traversal; and (4) skipping slot sealing when embedding engines patch the transfer hook, exposing undefined behaviour because the receiver reads from partially initialized records. The broken helper below illustrates the first two—note the missing tag gate and the fact that the source buffer is neither detached nor seal-checked, which Clang correctly warns about (“warning: variable ‘desc’ is used uninitialized”).\n```c\nint sc_emit_leaf(struct sc_context *ctx, const struct sc_value *value)\n{\n    struct sc_arraybuffer_desc desc;\n    if (value->tag == TAG_ARRAYBUFFER)\n        memcpy(arena_alloc(ctx, desc.length), desc.data, desc.length); /* UB */\n    /* falls through when tag == TAG_FUNCTION, so decoder sees garbage */\n    return 0;\n}\n```\nA safe variant rejects function-like tags up front, seals the slot before copying, detaches the source, and logs identity hits for cyclic graphs so the traversal stack never replays children.\n```c\nint sc_emit_leaf(struct sc_context *ctx, const struct sc_value *value)\n{\n    if (value->tag == TAG_FUNCTION)\n        return -EINVAL;\n    if (value->tag == TAG_ARRAYBUFFER) {\n        const struct sc_arraybuffer_desc *desc = value->opaque;\n        void *dst = arena_alloc(ctx, desc->length);\n        if (!dst)\n            return -ENOMEM;\n        memcpy(dst, desc->data, desc->length);\n        sc_mark_detached(desc);\n        return sc_register_identity(ctx, value);\n    }\n    return sc_encode_transferable(ctx, value);\n}\n```\nAlways seal object slots before handing buffers to user hooks and ensure every cyclic prototype edge visits `sc_register_identity` exactly once; otherwise worker cancellation leaves transferables half-owned and readers dereference stale pointers.",
    "is_complete": false,
    "next_focus": "Detail resource-leak and signal-safety risks when cloning is interrupted (worker termination, cancellation) and mitigation strategies."
  }
}