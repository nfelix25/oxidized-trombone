{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "worked-example-typedarray-clone",
    "type": "worked_example",
    "content": "To understand typed array cloning under load, imagine the JS payload `message = { matrix: new Float32Array(6), channels: [ { mask: new Uint8Array(4) }, new Uint8Array(4) ] }`. The encoder starts by pushing the root object onto its DFS stack. Each time a container (object or array) is popped, it emits a tag plus child-count header, then pushes the children in reverse so the wire format preserves insertion order without recursion. When a TypedArray leaf appears, it reserves space in the clone buffer, copies the backing store bytes, records the byte length, and flips the source descriptor into the detached state.\n\nThe worked program below mirrors that control flow. Frames in `stack` model the traversal stack used inside `sc_encode_value`. `emit_typed` stands in for the ArrayBuffer duplication step: it writes the typed tag, the byte length, then the payload itself. Container frames write deterministic headers before descending; when `next_child` equals the child count, the frame is popped, recreating the unwind that would normally trigger reference-table bookkeeping.\n\nRunning it pushes three container frames (`message`, `channels`, `layer0`) and three leaves; `write` flushes the contiguous buffer to STDOUT, while `dprintf` reports the byte length. Because each container header is 8 bytes (tag + child count) and each TypedArray contributes `8 + payload_length` bytes, the reported `used` equals `3*8 + (8+24) + (8+4) + (8+4) = 80`, proving that every buffer was duplicated exactly once before the traversal stack empties.\n\n```c\n#include <stdint.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nenum node_kind {\n    NODE_OBJECT = 0x10u,\n    NODE_ARRAY = 0x11u,\n    NODE_TYPED_FLOAT32 = 0x20u,\n    NODE_TYPED_UINT8 = 0x21u\n};\n\nstruct typed_view {\n    const void *data;\n    size_t length;\n    uint32_t tag;\n};\n\nstruct node {\n    enum node_kind kind;\n    const char *label;\n    union {\n        struct {\n            const struct node *const *children;\n            size_t child_count;\n        } comp;\n        struct typed_view typed;\n    } as;\n};\n\nstruct clone_frame {\n    const struct node *node;\n    size_t next_child;\n};\n\nstatic size_t emit_typed(uint8_t *dst, size_t cap, const struct typed_view *view)\n{\n    const size_t needed = sizeof(uint32_t) * 2 + view->length;\n    if (cap < needed)\n        return 0;\n    memcpy(dst, &view->tag, sizeof(uint32_t));\n    uint32_t bytes = (uint32_t)view->length;\n    memcpy(dst + sizeof(uint32_t), &bytes, sizeof(uint32_t));\n    memcpy(dst + sizeof(uint32_t) * 2, view->data, view->length);\n    return needed;\n}\n\nint main(void)\n{\n    float matrix_data[6] = { 1.f, 0.f, 0.f, 0.f, 1.f, 0.f };\n    uint8_t mask_data[4] = { 0, 1, 1, 0 };\n    uint8_t gradient_data[4] = { 4, 5, 6, 7 };\n\n    struct typed_view matrix_view = { matrix_data, sizeof(matrix_data), NODE_TYPED_FLOAT32 };\n    struct typed_view mask_view = { mask_data, sizeof(mask_data), NODE_TYPED_UINT8 };\n    struct typed_view gradient_view = { gradient_data, sizeof(gradient_data), NODE_TYPED_UINT8 };\n\n    struct node matrix_node = { NODE_TYPED_FLOAT32, \"matrix\", .as.typed = matrix_view };\n    struct node mask_node = { NODE_TYPED_UINT8, \"mask\", .as.typed = mask_view };\n    struct node gradient_node = { NODE_TYPED_UINT8, \"gradient\", .as.typed = gradient_view };\n\n    const struct node *const layer_children[] = { &mask_node };\n    struct node layer_obj = { NODE_OBJECT, \"layer0\", .as.comp = { layer_children, 1 } };\n\n    const struct node *const channel_children[] = { &layer_obj, &gradient_node };\n    struct node channels = { NODE_ARRAY, \"channels\", .as.comp = { channel_children, 2 } };\n\n    const struct node *const root_children[] = { &matrix_node, &channels };\n    struct node root = { NODE_OBJECT, \"message\", .as.comp = { root_children, 2 } };\n\n    struct clone_frame stack[16];\n    size_t sp = 0;\n    stack[sp++] = (struct clone_frame){ .node = &root, .next_child = 0 };\n\n    uint8_t buffer[512];\n    size_t used = 0;\n\n    while (sp > 0) {\n        struct clone_frame *frame = &stack[sp - 1];\n        if (frame->node->kind == NODE_TYPED_FLOAT32 || frame->node->kind == NODE_TYPED_UINT8) {\n            size_t wrote = emit_typed(buffer + used, sizeof(buffer) - used, &frame->node->as.typed);\n            if (!wrote)\n                return EXIT_FAILURE;\n            used += wrote;\n            --sp;\n            continue;\n        }\n\n        if (frame->next_child == 0) {\n            uint32_t header[2] = {\n                (uint32_t)frame->node->kind,\n                (uint32_t)frame->node->as.comp.child_count\n            };\n            if (sizeof(buffer) - used < sizeof(header))\n                return EXIT_FAILURE;\n            memcpy(buffer + used, header, sizeof(header));\n            used += sizeof(header);\n        }\n\n        if (frame->next_child == frame->node->as.comp.child_count) {\n            --sp;\n            continue;\n        }\n\n        if (sp == sizeof(stack) / sizeof(stack[0]))\n            return EXIT_FAILURE;\n\n        const struct node *child = frame->node->as.comp.children[frame->next_child++];\n        stack[sp++] = (struct clone_frame){ .node = child, .next_child = 0 };\n    }\n\n    if (write(STDOUT_FILENO, buffer, used) < 0)\n        return EXIT_FAILURE;\n\n    dprintf(STDERR_FILENO, \"serialized %zu bytes\\n\", used);\n    return EXIT_SUCCESS;\n}\n```\n",
    "is_complete": false,
    "next_focus": "Worked example: transferring a MessagePort plus SharedArrayBuffer between workers, detailing the syscall/IPC hooks and state transitions."
  }
}