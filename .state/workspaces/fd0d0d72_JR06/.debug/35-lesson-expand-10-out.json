{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "structured-clone-bridge",
    "type": "bridge",
    "content": "Transferable streams and zero-copy IPC schedulers are the natural sequel to structured clone: once every transferable is tagged, detached, and reference-counted, you can promise the scheduler that large payloads no longer need to bounce through clone arenas at all. The remaining constraint is bookkeepingâ€”streams must sample the same ownership bits you already maintain for ArrayBuffers, SharedArrayBuffers, and MessagePorts, otherwise a supposedly zero-copy frame might still hold onto a stale JS heap pointer. When you prepare the handoff table for a streaming transport, you reuse the transfer registry as the authority that says which buffers are safe to present as scatter/gather vectors, which ports are still entangled, and which SAB handles require atomics to stay armed while the stream pumps data. That makes structured clone the feasibility gate: if a value cannot survive clone validation, the stream scheduler cannot trust it for zero-copy either. Embedding runtimes therefore add a thin shim that translates transferables into stream slots before the IPC layer wakes its poll loop:\n```c\n#include <stddef.h>\nint sc_stage_transferable_stream(struct sc_context *ctx,\n                                 struct sc_transferable_desc *desc,\n                                 struct sc_stream_slot *slot)\n{\n    if (sc_context_register_transferable(ctx, desc))\n        return -EEXIST;\n    slot->handle = desc->handle;\n    slot->length = desc->length;\n    slot->flags = STREAM_FLAG_ZERO_COPY;\n    return sc_schedule_zero_copy(slot);\n}\n```\nBy the time you dive into transferable streams, this shim is already doing most of the work: it enforces the clone invariants, then exposes the descriptors in a format the zero-copy scheduler can consume without revalidating JavaScript objects. That alignment keeps the next module focused on throughput (batching, back-pressure, DMA) instead of rehashing ownership rules you have already encoded in the clone context.",
    "is_complete": true,
    "next_focus": ""
  }
}