{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "structured-clone-phases",
    "type": "concept",
    "content": "Inside a runtime the structured clone path is three interlocking loops: tag emission, traversal bookkeeping, and transferable vetting. Tagging is the lingua franca between engine and Worker—the encoder maps every JS shape to a compact enum plus length prefix so the decoder never has to second-guess byte boundaries. The traversal stack is a deterministic DFS queue that remembers every edge you have already walked, allowing identity-preserving back-references without recursion depth blowups. Finally, the transfer list is a guarded side channel: every ArrayBuffer, SharedArrayBuffer, or MessagePort is validated once, annotated with ownership bits, and either duplicated or moved before the payload leaves the thread. A minimal C skeleton looks like this:\n```c\nint sc_clone(struct sc_context *ctx, const struct sc_value *root,\n             struct sc_encoded_buffer *encoded,\n             struct sc_transferable_desc *xfer, size_t xfer_count)\n{\n    if (sc_context_init(ctx, 64 * 1024))\n        return -ENOMEM;\n    if (sc_encode_value(ctx, root, encoded))\n        return sc_context_free(ctx);\n    if (sc_commit_transfer_list(ctx, &(struct sc_message_record){\n            .root = root, .transfer_list = xfer, .transfer_count = xfer_count }))\n        return sc_context_free(ctx);\n    return 0;\n}\n```\nReal engines split those calls across subsystems but the flow is identical: type tags are written as you pop items off the traversal stack, every new pointer is registered into the identity table, and the transfer validator either decorates the encoded stream with handles (SAB, ports) or copies bytes (ArrayBuffers) before the executor posts the message.",
    "is_complete": false,
    "next_focus": "Explain lifecycle tracking for transferables—ArrayBuffer, SharedArrayBuffer, MessagePort—and how ownership moves between workers without data races."
  }
}