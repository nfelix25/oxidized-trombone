{
  "accepted": true,
  "schemaName": "starter_section_v1",
  "payload": {
    "schema_version": "starter_section_v1",
    "role": "starter-expand",
    "section_id": "structured-clone-encoder-h",
    "type": "code",
    "file_path": "structured_clone_encoder.h",
    "content": "#ifndef STRUCTURED_CLONE_ENCODER_H\n#define STRUCTURED_CLONE_ENCODER_H\n\n#include <stddef.h>\n#include \"structured_clone_context.h\"\n\nstruct sc_encoded_buffer {\n    void *data;\n    size_t length;\n    size_t capacity;\n};\n\nstruct sc_value {\n    const void *opaque;\n    unsigned int tag;\n};\n\nstruct sc_arraybuffer_desc {\n    const void *data;\n    size_t length;\n    unsigned int flags;\n};\n\nstruct sc_shared_arraybuffer_desc {\n    int handle;\n    size_t length;\n    unsigned int flags;\n};\n\nstruct sc_message_record {\n    const struct sc_value *root;\n    const struct sc_transferable_desc *transfer_list;\n    size_t transfer_count;\n};\n\n/* Encode an arbitrary worker message so the learner must walk the graph depth-first, attach type tags, and surface -EINVAL for unsupported constructs. */\nint sc_encode_value(struct sc_context *ctx,\n                    const struct sc_value *root,\n                    struct sc_encoded_buffer *out);\n\n/* Clone an ArrayBuffer payload so the learner must copy bytes, mark detachment out of band, and flag -EMSGSIZE when the buffer exceeds limits. */\nint sc_encode_arraybuffer(struct sc_context *ctx,\n                          const struct sc_arraybuffer_desc *src,\n                          struct sc_encoded_buffer *out);\n\n/* Serialize a SharedArrayBuffer handle so the learner must emit handle IDs, check atomics capability, and reject illegal transfers with -EPERM. */\nint sc_encode_shared_arraybuffer(struct sc_context *ctx,\n                                 const struct sc_shared_arraybuffer_desc *src,\n                                 struct sc_encoded_buffer *out);\n\n/* Assemble the final postMessage payload so the learner must stitch headers, body vectors, and enforce maximum IPC frame sizes before enqueueing. */\nint sc_encode_postmessage_payload(struct sc_context *ctx,\n                                  const struct sc_message_record *record,\n                                  struct sc_encoded_buffer *out);\n\n#endif /* STRUCTURED_CLONE_ENCODER_H */\n",
    "is_complete": false,
    "next_focus": "structured_clone_executor.c"
  }
}