{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "bridge_auto_to_templates",
    "type": "bridge",
    "content": "Mastering `auto` at the primitive level is the on-ramp to template-heavy, generic C++ where type names stretch across screens. Consider how reusable algorithms lean on deduction to stay terse:\n```cpp\n#include <algorithm>\n#include <array>\n#include <type_traits>\n#include <vector>\n\ntemplate <typename Range, typename Pred>\nauto collect_if(const Range& range, Pred pred) {\n  using Value = std::remove_cvref_t<decltype(*range.begin())>;\n  std::vector<Value> result;\n  for (const auto& item : range) {\n    if (pred(item)) { result.push_back(item); }\n  }\n  return result; // auto deduces std::vector<Value>\n}\n\nint main() {\n  const std::array<double, 4> readings{4.9, 5.1, 4.95, 5.3};\n  auto spikes = collect_if(readings, [](double v) { return v > 5.0; });\n}\n```\nEvery bolded decision from this lesson—using `const auto&` in loops, seeding arithmetic with the widest sensible type, guarding qualifiers with references—translates directly into template utilities like `collect_if`. The template itself only names `Range` and `Pred`; all other types emerge from expressions: the dereferenced iterator, the lambda return value, the container we build. When you understand how `auto` captures each of those deductions, interpreting `std::vector<std::remove_cvref_t<decltype(*range.begin())>>` no longer feels like magic, and you can predict when extra `const` or `&` belongs. Next module we escalate to full generic algorithms, but the same instincts apply: inspect initializers, read diagnostics, and state mutability explicitly so deduction works for you instead of surprising you.",
    "is_complete": true,
    "next_focus": ""
  }
}