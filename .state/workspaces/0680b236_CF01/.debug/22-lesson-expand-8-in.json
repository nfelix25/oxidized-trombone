{
  "schema_version": "context_packet_v1",
  "packet_id": "ff2c2f7b-48e3-4040-98b6-748fb2208070",
  "timestamp_utc": "2026-02-25T00:38:43.832Z",
  "role": "lesson-expand",
  "task_type": "lesson_expand",
  "learner_profile": {
    "masteryLevel": 0
  },
  "curriculum_context": {
    "node_id": "CF01",
    "depth_target": "D1"
  },
  "misconception_context": {
    "top_tags": []
  },
  "attempt_context": null,
  "evidence_context": null,
  "policy_context": {
    "allow_reveal": false
  },
  "memory_context": {},
  "scaffold_context": {
    "scaffold_id": "e8a0c2c8-7259-4c90-9a30-11f15d2c003d",
    "exercise_description": "Design a deep-dive exercise on C++ type deduction with `auto`, emphasizing safe initialization, const-correctness, and observing how inference interacts with primitive types and references.",
    "lesson_plan": {
      "section_intents": [
        "Hook: Contrast implicit vs explicit variable declarations in a debugging story to motivate careful type tracking.",
        "Concept Focus: Explain primitive types (int, double, bool, char) and initialization styles that pair best with type inference.",
        "Tooling: Demonstrate how `auto` deduces types from initializer expressions, including reading compiler diagnostics.",
        "Worked Example 1: Use range-based for loops with `auto` iterators and `const auto&` to preserve immutability.",
        "Worked Example 2: Showcase `auto` with arithmetic expressions mixing ints and doubles; highlight precision and promotion.",
        "Pitfalls: Investigate cases where `auto` strips references/const, leading to dangling references or UB, plus remedy patterns.",
        "Comparison: Contrast `auto` in C++ with `var`-style inference in C#/Rust to emphasize explicitness requirements.",
        "Bridge: Preview how mastering `auto` prepares learners for templates and generic algorithms in the next module."
      ]
    },
    "starter_plan": {
      "file_intents": [
        "src/type_workshop.h: Declare 4 stub functions (e.g., `inferSumType`, `preserveConstRef`, `boolFlagFromChar`, `charFromBool`) with Doxygen comments describing expected behavior and parameters.",
        "src/type_workshop.cpp: Provide empty implementations for the declared functions, each returning placeholder values and marked TODO for learners."
      ]
    },
    "test_plan": {
      "case_intents": [
        "Verify `inferSumType` returns a double when combining int and double inputs.",
        "Confirm `inferSumType` preserves integer type when both operands are ints.",
        "Ensure `preserveConstRef` returns a const reference without slicing when given const data.",
        "Detect that `preserveConstRef` does not bind to temporaries (dangling reference guard).",
        "Check `boolFlagFromChar` maps ASCII digits to true/false according to spec.",
        "Check `boolFlagFromChar` rejects non-digit chars with a safe default.",
        "Validate `charFromBool` returns explicit 'T'/'F' without relying on implicit bool-to-char conversions.",
        "Edge case: stress `inferSumType` with very large ints to ensure no narrowing or UB.",
        "Edge case: feed `preserveConstRef` a volatile-qualified source to confirm qualifiers survive.",
        "Edge case: ensure `charFromBool` handles `std::optional<bool>` inputs when empty via default character."
      ]
    }
  },
  "prior_loop_sections": [
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "type_workshop_h",
      "type": "code",
      "file_path": "type_workshop.h",
      "content": "#pragma once\n\n#include <optional>\n\nnamespace type_workshop {\n\n/// Demonstrates `auto` return type deduction by summing mixed primitive values.\n/// @param lhs First addend supplied as any arithmetic type to show template argument deduction.\n/// @param rhs Second addend supplied as any arithmetic type, possibly with higher precision.\n/// @return The deduced common type produced by lhs + rhs, letting learners trace promotions.\n/// @note Learners must implement safe addition logic that preserves precision without narrowing.\ntemplate <typename T, typename U>\nauto inferSumType(const T& lhs, const U& rhs) -> decltype(lhs + rhs);\n\n/// Highlights const-correctness by forwarding stable references and preventing dangling bindings.\n/// @param value Immutable source object that should be returned as a const reference.\n/// @return A const reference that keeps every qualifier (const, volatile, reference) intact.\n/// @note Learners must ensure temporaries are rejected or extended safely while preserving qualifiers.\ntemplate <typename T>\nconst T& preserveConstRef(const T& value);\n\n/// Explores character-to-boolean inference rules with ASCII digits and defensive defaults.\n/// @param digit Character that may describe a '0'/'1' flag or other sentinel input.\n/// @return True/false according to the learner-defined mapping, defaulting safely for invalid chars.\n/// @note Learners must guard against undefined behavior by validating digits before deduction.\nbool boolFlagFromChar(char digit);\n\n/// Connects `std::optional` with explicit character outputs to avoid implicit bool-to-char casts.\n/// @param flag Optional boolean sourced from diagnostics or configuration data.\n/// @return 'T'/'F' (or a learner-chosen fallback) conveying the optional state without ambiguity.\n/// @note Learners must cover engaged/empty optionals and document how auto interacts with conditionals.\nchar charFromBool(const std::optional<bool>& flag);\n\n}  // namespace type_workshop\n",
      "is_complete": false,
      "next_focus": "type_workshop.cpp"
    },
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "type_workshop_cpp",
      "type": "code",
      "file_path": "type_workshop.cpp",
      "content": "#include \"type_workshop.h\"\n\nnamespace type_workshop {\n\n/// Demonstrates how `auto` deduces a common arithmetic type for sums and what learners must implement to avoid narrowing.\n/// @param lhs First operand showcasing integral inputs.\n/// @param rhs Second operand showcasing floating inputs.\n/// @return The deduced promoted type representing lhs + rhs.\n/// @note Learners must implement precise addition without truncation.\ntemplate <typename T, typename U>\nauto inferSumType(const T& lhs, const U& rhs) -> decltype(lhs + rhs) {\n  // TODO: implement mixed-type addition respecting auto promotions.\n  return {};\n}\n\n/// Highlights const-reference binding rules so learners can practice preserving qualifiers end-to-end.\n/// @param value Immutable source tied to diagnostics.\n/// @return A const reference mirroring the input qualifiers.\n/// @note Learners must ensure temporaries are rejected to avoid dangling references.\ntemplate <typename T>\nconst T& preserveConstRef(const T& value) {\n  // TODO: implement qualifier-preserving reference forwarding.\n  return value;\n}\n\n/// Explains mapping ASCII digits to boolean flags to reinforce defensive parsing with `auto` deduction of conditionals.\n/// @param digit Character inspected for '0' or '1'.\n/// @return Boolean describing the interpreted flag state.\n/// @note Learners must validate characters before toggling flags.\nbool boolFlagFromChar(const char digit) {\n  // TODO: implement digit validation and boolean mapping.\n  return false;\n}\n\n/// Connects std::optional<bool> with explicit character outputs to avoid implicit conversions when using auto in control flow.\n/// @param flag Optional input that may be engaged or empty.\n/// @return 'T', 'F', or a fallback char for std::nullopt.\n/// @note Learners must cover empty optionals without UB.\nchar charFromBool(const std::optional<bool>& flag) {\n  // TODO: implement optional handling with explicit character mapping.\n  return {};\n}\n\n}  // namespace type_workshop\n",
      "is_complete": true,
      "next_focus": ""
    },
    {
      "schema_version": "test_section_v1",
      "role": "test-expand",
      "section_id": "type_workshop_tests",
      "type": "code",
      "file_path": "type_workshop_tests.cpp",
      "content": "#include <gtest/gtest.h>\n#include \"solution.h\"\n#include <limits>\n#include <optional>\n#include <stdexcept>\n#include <string>\n#include <type_traits>\n\nnamespace {\nstruct BaseFlag {\n  int id = 0;\n  virtual ~BaseFlag() = default;\n};\n\nstruct DerivedFlag : BaseFlag {\n  int extra = 0;\n  DerivedFlag(int base_value, int extra_value) {\n    id = base_value;\n    extra = extra_value;\n  }\n};\n}  // namespace\n\nTEST(InferSumType, IntAndDoublePromotesToDouble) {\n  auto result = type_workshop::inferSumType(4, 2.5);\n  EXPECT_TRUE((std::is_same_v<decltype(result), double>));\n  EXPECT_DOUBLE_EQ(result, 6.5);\n}\n\nTEST(InferSumType, IntPairStaysInteger) {\n  auto result = type_workshop::inferSumType(3, 5);\n  EXPECT_TRUE((std::is_same_v<decltype(result), int>));\n  EXPECT_EQ(result, 8);\n}\n\nTEST(InferSumType, HandlesLargeIntegersSafely) {\n  const long long near_max = std::numeric_limits<long long>::max() - 1;\n  auto result = type_workshop::inferSumType(near_max, 1LL);\n  EXPECT_TRUE((std::is_same_v<decltype(result), long long>));\n  EXPECT_EQ(result, std::numeric_limits<long long>::max());\n}\n\nTEST(PreserveConstRef, ReturnsConstReferenceWithoutSlicing) {\n  const DerivedFlag derived(42, 99);\n  const auto& ref = type_workshop::preserveConstRef(derived);\n  EXPECT_EQ(&ref, &derived);\n  const BaseFlag& base_view = ref;\n  EXPECT_EQ(base_view.id, 42);\n  EXPECT_EQ(ref.extra, 99);\n}\n\nTEST(PreserveConstRef, RejectsTemporaries) {\n  EXPECT_THROW(\n      {\n        const auto& ref =\n            type_workshop::preserveConstRef(std::string{\"temporary\"});\n        (void)ref;\n      },\n      std::logic_error);\n}\n\nTEST(PreserveConstRef, KeepsVolatileQualifier) {\n  volatile int counter = 7;\n  const volatile int& ref = type_workshop::preserveConstRef(counter);\n  EXPECT_TRUE((std::is_same_v<decltype(ref), const volatile int&>));\n  counter = 11;\n  EXPECT_EQ(ref, 11);\n}\n\nTEST(BoolFlagFromChar, ZeroIsFalseOneIsTrue) {\n  EXPECT_FALSE(type_workshop::boolFlagFromChar('0'));\n  EXPECT_TRUE(type_workshop::boolFlagFromChar('1'));\n}\n\nTEST(BoolFlagFromChar, NonDigitsUseSafeDefault) {\n  EXPECT_FALSE(type_workshop::boolFlagFromChar('x'));\n  EXPECT_FALSE(type_workshop::boolFlagFromChar('/'));\n}\n\nTEST(CharFromBool, UsesExplicitLetters) {\n  EXPECT_EQ(type_workshop::charFromBool(std::optional<bool>{true}), 'T');\n  EXPECT_EQ(type_workshop::charFromBool(std::optional<bool>{false}), 'F');\n}\n\nTEST(CharFromBool, HandlesEmptyOptionalWithFallback) {\n  EXPECT_EQ(type_workshop::charFromBool(std::nullopt), '?');\n}\n",
      "is_complete": true,
      "next_focus": ""
    }
  ],
  "current_sections": [
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "hook_implicit_vs_explicit",
      "type": "concept",
      "content": "During a midnight telemetry bug hunt, our rover kept resetting because a supposedly small counter silently bloated into a wide floating-point value. A teammate had chased ghost overflows for hours until we realized the culprit was an innocent-looking `auto` declaration that deduced a different type than the explicit spec in the design doc. To recreate the scene, contrast the implicit code we found with the explicit patch that finally stabilized the readings:\n```cpp\n// Implicit: type inferred from the literal 0, later reassigned a double\nauto packetBudget = 0;        // int\npacketBudget = 0.75 * frames; // narrows silently on most builds\n\n// Explicit: mirrors the diagnostic spreadsheets\ndouble packetBudget = 0.0;\npacketBudget = 0.75 * frames; // preserves precision across platforms\n```\nThe difference isn’t syntax vanity—it’s the ability to reason about every intermediate value when logs go quiet and hardware sits millions of miles away. In this module we’ll embrace `auto`, but with the same discipline that saved the rover: knowing what primitive type is actually deduced, how initialization style nudges that deduction, and what clues the compiler can give before a faulty variable forces a reboot. Keep that late-night debugging story in mind as motivation for tracking types deliberately, even when the compiler happily guesses for you.",
      "is_complete": false,
      "next_focus": "Concept Focus: Explain primitive types (int, double, bool, char) and initialization styles that pair best with type inference."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "concept_primitive_types_initialization",
      "type": "concept",
      "content": "Before caring about `auto`, anchor on the four primitive workhorses that every deduction funnels through: `int` for whole counts, `double` for fractional telemetry, `bool` for control flags, and `char` for byte-sized symbols. Each has multiple initialization styles, and the style determines whether `auto` can mirror your intent or betrays it with narrowing. Brace initialization (`{}`) is the most defensive because it rejects narrowing outright; copy (`=`) and direct `()` initialization allow implicit conversions, so the compiler may quietly trim data. Consider this small diagnostic harness:\n```cpp\nint packets = 120;            // copy-init, OK: literal fits in int\ndouble energy{42.75};        // brace-init, forbids accidental truncation\nbool ready = true;            // copy-init from bool literal stays bool\nchar status('A');             // direct-init from character literal\nauto ratio = packets / energy;      // deduced double because energy is double\nauto flag = bool{status == 'A'};    // deduced bool; brace guards against typo narrowing\nauto symbol = char{ready ? 'Y' : 'N'}; // deduced char explicitly\n```\nWhen primitives are initialized deliberately, `auto` becomes a faithful stenographer of the expression’s true type rather than a wildcard. Conversely, letting `auto` deduce from a bare literal (`auto id = 0;`) defaults to `int`, which may clash later if you mix it with doubles or expect a distinct character encoding. Treat initialization style as the contract that informs inference before we add templates or optional flags to the mix.",
      "is_complete": false,
      "next_focus": "Tooling: Demonstrate how `auto` deduces types from initializer expressions, including reading compiler diagnostics."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "tooling_auto_diagnostics",
      "type": "concept",
      "content": "Modern compilers will happily show what `auto` deduced if you ask. Pair a quick probe program with diagnostics flags to surface mismatches early:\n```cpp\n#include <type_traits>\n#include <iostream>\n\ntemplate <typename T>\nvoid inspect(const char* label, const T&) {\n  std::cout << label << \" -> \" << __PRETTY_FUNCTION__ << '\\n';\n}\n\nint main() {\n  auto samples = {42, 3.14};   // deduces std::initializer_list<double>\n  auto flag = '1' - '0';        // deduces int after char arithmetic\n  const int counts[] = {1, 2, 3};\n  for (const auto& c : counts) { inspect(\"loop var\", c); }\n  inspect(\"flag\", flag);\n}\n```\nCompiling with `clang++ -std=c++20 -Wall -Wconversion deduce.cpp` emits both the pretty-function strings and any conversion warnings. For example, `deduce.cpp:5:17: warning: implicit conversion changes signedness` immediately flags where an `auto` variable quietly changed representation. GCC lacks `__PRETTY_FUNCTION__` detail, so add `static_assert(std::is_same_v<decltype(flag), int>);` or use `-fdump-lang-class` to inspect AST nodes. IDEs such as VS Code (clangd) or CLion expose the deduced type when you hover over the variable name—verify that hover output matches `decltype` checks so you don’t trust stale UI caches. Treat diagnostics as part of the workflow: run with `-Wconversion -Wshadow` whenever you add `auto`, and wire `typeid(variable).name()` prints or `std::same_as` assertions into your unit tests so regression suites scream the moment inference stops matching the spec. That tooling feedback loop keeps type inference observable instead of mystical.",
      "is_complete": false,
      "next_focus": "Worked Example 1: Use range-based for loops with `auto` iterators and `const auto&` to preserve immutability."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "worked_example_const_auto_for",
      "type": "worked_example",
      "content": "Watch how `const auto&` keeps telemetry frames immutable while still letting us categorize them:\n```cpp\n#include <array>\n#include <cstdint>\n#include <iostream>\n#include <numeric>\n\nstruct Frame {\n  std::uint32_t id;\n  double voltage;\n};\n\nint main() {\n  const std::array<Frame, 3> frames{{\n      {1001u, 4.98},\n      {1002u, 4.65},\n      {1003u, 5.05},\n  }};\n\n  std::size_t overSpec = 0;\n  double totalVoltage = 0.0;\n\n  for (const auto& frame : frames) {     // deduces const Frame&\n    if (frame.voltage > 5.0) {\n      ++overSpec;\n    }\n    totalVoltage += frame.voltage;        // safe: frame is read-only\n  }\n\n  const auto average = totalVoltage / frames.size();\n  std::cout << overSpec << \" frames exceed spec; avg=\" << average << '\\n';\n}\n```\nKey deductions: the `frames` container is `const`, so `const auto&` binds to each element without copying. Mutating `frame.voltage` would be a compile-time error, preserving invariants while still permitting accumulation via separate `auto` temporaries (`overSpec`, `totalVoltage`). Try swapping the loop header to `for (auto frame : frames)` and your compiler copies every `Frame`, making edits silently mutate only the local copy—exactly the kind of bug that hides in reviews. Hovering or adding `static_assert(std::is_same_v<decltype(frame), const Frame&>);` confirms the inference. This pattern scales to STL views: `for (const auto& reading : std::as_const(readings))` guarantees analysts can read telemetry, categorize it, and feed aggregates downstream without risking accidental writes, a critical habit before we layer templates and optionals onto our loops.",
      "is_complete": false,
      "next_focus": "Worked Example 2: Showcase `auto` with arithmetic expressions mixing ints and doubles; highlight precision and promotion."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "worked_example_mixed_arithmetic",
      "type": "worked_example",
      "content": "`auto` shines when you mix primitive types, as long as you predict the promotions. Here’s a telemetry snippet that tallies thruster pulses (integers) and combines them with a fractional timing constant:\n```cpp\n#include <iomanip>\n#include <iostream>\n#include <numeric>\n#include <vector>\n\nint main() {\n  const std::vector<int> pulseCounts{1200, 1190, 1215};\n  const double secondsPerPulse = 0.0042; // precise calibration constant\n\n  auto totalPulses = std::accumulate(pulseCounts.begin(),\n                                     pulseCounts.end(), 0LL);\n  const auto totalSeconds = totalPulses * secondsPerPulse;\n  const auto avgPulsesPerSecond =\n      static_cast<double>(totalPulses) / totalSeconds;\n\n  std::cout << \"total pulses: \" << totalPulses << '\\n'\n            << std::fixed << std::setprecision(3)\n            << \"duration: \" << totalSeconds << \" s\\n\"\n            << \"avg pulses/s: \" << avgPulsesPerSecond << '\\n';\n}\n```\nImportant deductions: `std::accumulate` seeds with `0LL`, so `totalPulses` becomes a `long long`, guarding against overflow that would occur with a 32-bit `int`. Multiplying that `long long` by the `double` constant forces `totalSeconds` to be a `double`, capturing fractional time exactly. Without the explicit `static_cast<double>` in the rate calculation, integer division would truncate before promotion, so the cast ensures `avgPulsesPerSecond` stays double-precision. Move the seed to `0` and watch `totalPulses` collapse to `int`, potentially truncating when pulses exceed two billion. This workflow—seed with the widest integral type you need, let `auto` follow the precision of mixed expressions, and cast only at the comparison boundaries—keeps inference transparent while highlighting how arithmetic promotions dictate the final deduced types.",
      "is_complete": false,
      "next_focus": "Pitfalls: Investigate cases where `auto` strips references/const, leading to dangling references or UB, plus remedy patterns."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "pitfalls_auto_reference_decay",
      "type": "pitfalls",
      "content": "Two easy-to-miss traps prove why we must deliberately annotate `auto` when qualifiers matter. First, `auto` strips top-level `const`/`volatile`, so any guard you assume is gone unless you reintroduce it:\n```cpp\n#include <type_traits>\n\nint main() {\n  const volatile int watchdog = 7;\n  auto alias = watchdog; // alias is plain int!\n  static_assert(std::is_same_v<decltype(alias), const volatile int>,\n                \"alias lost qualifiers\");\n}\n```\n```\npitfall.cpp:10:3: error: static assertion failed: alias lost qualifiers\n```\nPin the intent by binding a reference or reapplying cv-qualifiers explicitly:\n```cpp\nconst volatile auto& alias = watchdog;     // preserves every qualifier\ndecltype(auto) forwarded = watchdog;       // mirrors the declaration exactly\n```\nThe second pitfall: valuing a reference with `auto` manufactures a new object whose lifetime ends at scope exit, yet we might still return a reference to it:\n```cpp\n#include <iostream>\n#include <string>\n\nconst std::string& chooseLabel(const std::string& prefix) {\n  auto label = prefix + \"_TMP\"; // fresh std::string copy\n  return label;                  // dangling reference\n}\n\nint main() { std::cout << chooseLabel(\"MODE\") << '\\n'; }\n```\n```\npitfall.cpp:18:12: runtime error: reference binding to stack memory associated with variable 'label'\n```\nRemedy patterns include returning by value (`std::string`) when you create new data, or binding explicitly with `const auto& label = prefix;` when you merely alias an existing object. More advanced cases (forwarding functions) should use `decltype(auto)` plus `std::forward<T>(value)` to preserve references through templates. Keep repeating the mantra: add `&` when you expect aliasing, add `const` when you expect immutability, and assume bare `auto` means “make a new copy.”",
      "is_complete": false,
      "next_focus": "Comparison: Contrast `auto` in C++ with `var`-style inference in C#/Rust to emphasize explicitness requirements."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "comparison_cpp_auto_vs_var",
      "type": "comparison",
      "content": "C++ `auto` is fundamentally about *expressions*, so whatever category/value qualifiers the initializer exhibits dictate both the deduced type and the ownership semantics. That means you must spell out constness and references whenever you rely on them; otherwise the compiler eagerly materializes a fresh value. In C#, `var` and in Rust, the untyped `let` binding behave differently: they bind the *declared* variable to the inferred static type but keep qualifiers (mutability, reference-ness) handled by separate keywords, so there is less risk of silently losing immutability.\n```cpp\n#include <vector>\n#include <span>\n\nvoid tagPackets(std::vector<int>& packets) {\n  auto copy = packets;          // new std::vector<int>, mutations local\n  auto iter = packets.begin();  // iterator owning only a pointer-like handle\n  const auto& view = packets;   // must add & to alias original storage\n  std::span<int> window{packets};\n}\n```\n```csharp\nvar packets = new List<int> {1, 2, 3}; // still List<int>\nvar view = packets;                    // reference semantics by default\n```\n```rust\nlet packet = 42;        // immutable i32 unless `mut`\nlet mut alias = packet; // explicit mutability opt-in\n```\nIn Rust, you annotate borrowing (`&packets`, `&mut packets`) outside of type inference, so the compiler never strips references implicitly. C# similarly preserves reference semantics because objects live on the managed heap, and `var` merely copies the reference. By contrast, C++ performs copy semantics unless you write `auto&` or `const auto&`, so toggling between owning and aliasing must be a conscious syntax choice. Treat `auto` as a shortcut for long type spellings, not for ownership intent; introduce reference or pointer qualifiers explicitly so your code communicates the same guarantees that `var`/`let` give you for free in other ecosystems.",
      "is_complete": false,
      "next_focus": "Bridge: Preview how mastering `auto` prepares learners for templates and generic algorithms in the next module."
    }
  ],
  "next_focus": "Bridge: Preview how mastering `auto` prepares learners for templates and generic algorithms in the next module."
}