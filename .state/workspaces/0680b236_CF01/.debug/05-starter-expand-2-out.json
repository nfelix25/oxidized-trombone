{
  "accepted": true,
  "schemaName": "starter_section_v1",
  "payload": {
    "schema_version": "starter_section_v1",
    "role": "starter-expand",
    "section_id": "type_workshop_cpp",
    "type": "code",
    "file_path": "type_workshop.cpp",
    "content": "#include \"type_workshop.h\"\n\nnamespace type_workshop {\n\n/// Demonstrates how `auto` deduces a common arithmetic type for sums and what learners must implement to avoid narrowing.\n/// @param lhs First operand showcasing integral inputs.\n/// @param rhs Second operand showcasing floating inputs.\n/// @return The deduced promoted type representing lhs + rhs.\n/// @note Learners must implement precise addition without truncation.\ntemplate <typename T, typename U>\nauto inferSumType(const T& lhs, const U& rhs) -> decltype(lhs + rhs) {\n  // TODO: implement mixed-type addition respecting auto promotions.\n  return {};\n}\n\n/// Highlights const-reference binding rules so learners can practice preserving qualifiers end-to-end.\n/// @param value Immutable source tied to diagnostics.\n/// @return A const reference mirroring the input qualifiers.\n/// @note Learners must ensure temporaries are rejected to avoid dangling references.\ntemplate <typename T>\nconst T& preserveConstRef(const T& value) {\n  // TODO: implement qualifier-preserving reference forwarding.\n  return value;\n}\n\n/// Explains mapping ASCII digits to boolean flags to reinforce defensive parsing with `auto` deduction of conditionals.\n/// @param digit Character inspected for '0' or '1'.\n/// @return Boolean describing the interpreted flag state.\n/// @note Learners must validate characters before toggling flags.\nbool boolFlagFromChar(const char digit) {\n  // TODO: implement digit validation and boolean mapping.\n  return false;\n}\n\n/// Connects std::optional<bool> with explicit character outputs to avoid implicit conversions when using auto in control flow.\n/// @param flag Optional input that may be engaged or empty.\n/// @return 'T', 'F', or a fallback char for std::nullopt.\n/// @note Learners must cover empty optionals without UB.\nchar charFromBool(const std::optional<bool>& flag) {\n  // TODO: implement optional handling with explicit character mapping.\n  return {};\n}\n\n}  // namespace type_workshop\n",
    "is_complete": true,
    "next_focus": ""
  }
}