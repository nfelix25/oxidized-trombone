{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "pitfalls_auto_reference_decay",
    "type": "pitfalls",
    "content": "Two easy-to-miss traps prove why we must deliberately annotate `auto` when qualifiers matter. First, `auto` strips top-level `const`/`volatile`, so any guard you assume is gone unless you reintroduce it:\n```cpp\n#include <type_traits>\n\nint main() {\n  const volatile int watchdog = 7;\n  auto alias = watchdog; // alias is plain int!\n  static_assert(std::is_same_v<decltype(alias), const volatile int>,\n                \"alias lost qualifiers\");\n}\n```\n```\npitfall.cpp:10:3: error: static assertion failed: alias lost qualifiers\n```\nPin the intent by binding a reference or reapplying cv-qualifiers explicitly:\n```cpp\nconst volatile auto& alias = watchdog;     // preserves every qualifier\ndecltype(auto) forwarded = watchdog;       // mirrors the declaration exactly\n```\nThe second pitfall: valuing a reference with `auto` manufactures a new object whose lifetime ends at scope exit, yet we might still return a reference to it:\n```cpp\n#include <iostream>\n#include <string>\n\nconst std::string& chooseLabel(const std::string& prefix) {\n  auto label = prefix + \"_TMP\"; // fresh std::string copy\n  return label;                  // dangling reference\n}\n\nint main() { std::cout << chooseLabel(\"MODE\") << '\\n'; }\n```\n```\npitfall.cpp:18:12: runtime error: reference binding to stack memory associated with variable 'label'\n```\nRemedy patterns include returning by value (`std::string`) when you create new data, or binding explicitly with `const auto& label = prefix;` when you merely alias an existing object. More advanced cases (forwarding functions) should use `decltype(auto)` plus `std::forward<T>(value)` to preserve references through templates. Keep repeating the mantra: add `&` when you expect aliasing, add `const` when you expect immutability, and assume bare `auto` means “make a new copy.”",
    "is_complete": false,
    "next_focus": "Comparison: Contrast `auto` in C++ with `var`-style inference in C#/Rust to emphasize explicitness requirements."
  }
}