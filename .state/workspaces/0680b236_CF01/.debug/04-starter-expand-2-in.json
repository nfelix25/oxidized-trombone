{
  "schema_version": "context_packet_v1",
  "packet_id": "f40af902-cd47-49b1-8c7e-ea9ce1e4cd3c",
  "timestamp_utc": "2026-02-25T00:35:05.085Z",
  "role": "starter-expand",
  "task_type": "starter_expand",
  "learner_profile": {
    "masteryLevel": 0
  },
  "curriculum_context": {
    "node_id": "CF01",
    "depth_target": "D1"
  },
  "misconception_context": {
    "top_tags": []
  },
  "attempt_context": null,
  "evidence_context": null,
  "policy_context": {
    "allow_reveal": false
  },
  "memory_context": {},
  "scaffold_context": {
    "scaffold_id": "e8a0c2c8-7259-4c90-9a30-11f15d2c003d",
    "exercise_description": "Design a deep-dive exercise on C++ type deduction with `auto`, emphasizing safe initialization, const-correctness, and observing how inference interacts with primitive types and references.",
    "lesson_plan": {
      "section_intents": [
        "Hook: Contrast implicit vs explicit variable declarations in a debugging story to motivate careful type tracking.",
        "Concept Focus: Explain primitive types (int, double, bool, char) and initialization styles that pair best with type inference.",
        "Tooling: Demonstrate how `auto` deduces types from initializer expressions, including reading compiler diagnostics.",
        "Worked Example 1: Use range-based for loops with `auto` iterators and `const auto&` to preserve immutability.",
        "Worked Example 2: Showcase `auto` with arithmetic expressions mixing ints and doubles; highlight precision and promotion.",
        "Pitfalls: Investigate cases where `auto` strips references/const, leading to dangling references or UB, plus remedy patterns.",
        "Comparison: Contrast `auto` in C++ with `var`-style inference in C#/Rust to emphasize explicitness requirements.",
        "Bridge: Preview how mastering `auto` prepares learners for templates and generic algorithms in the next module."
      ]
    },
    "starter_plan": {
      "file_intents": [
        "src/type_workshop.h: Declare 4 stub functions (e.g., `inferSumType`, `preserveConstRef`, `boolFlagFromChar`, `charFromBool`) with Doxygen comments describing expected behavior and parameters.",
        "src/type_workshop.cpp: Provide empty implementations for the declared functions, each returning placeholder values and marked TODO for learners."
      ]
    },
    "test_plan": {
      "case_intents": [
        "Verify `inferSumType` returns a double when combining int and double inputs.",
        "Confirm `inferSumType` preserves integer type when both operands are ints.",
        "Ensure `preserveConstRef` returns a const reference without slicing when given const data.",
        "Detect that `preserveConstRef` does not bind to temporaries (dangling reference guard).",
        "Check `boolFlagFromChar` maps ASCII digits to true/false according to spec.",
        "Check `boolFlagFromChar` rejects non-digit chars with a safe default.",
        "Validate `charFromBool` returns explicit 'T'/'F' without relying on implicit bool-to-char conversions.",
        "Edge case: stress `inferSumType` with very large ints to ensure no narrowing or UB.",
        "Edge case: feed `preserveConstRef` a volatile-qualified source to confirm qualifiers survive.",
        "Edge case: ensure `charFromBool` handles `std::optional<bool>` inputs when empty via default character."
      ]
    }
  },
  "prior_loop_sections": [],
  "current_sections": [
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "type_workshop_h",
      "type": "code",
      "file_path": "type_workshop.h",
      "content": "#pragma once\n\n#include <optional>\n\nnamespace type_workshop {\n\n/// Demonstrates `auto` return type deduction by summing mixed primitive values.\n/// @param lhs First addend supplied as any arithmetic type to show template argument deduction.\n/// @param rhs Second addend supplied as any arithmetic type, possibly with higher precision.\n/// @return The deduced common type produced by lhs + rhs, letting learners trace promotions.\n/// @note Learners must implement safe addition logic that preserves precision without narrowing.\ntemplate <typename T, typename U>\nauto inferSumType(const T& lhs, const U& rhs) -> decltype(lhs + rhs);\n\n/// Highlights const-correctness by forwarding stable references and preventing dangling bindings.\n/// @param value Immutable source object that should be returned as a const reference.\n/// @return A const reference that keeps every qualifier (const, volatile, reference) intact.\n/// @note Learners must ensure temporaries are rejected or extended safely while preserving qualifiers.\ntemplate <typename T>\nconst T& preserveConstRef(const T& value);\n\n/// Explores character-to-boolean inference rules with ASCII digits and defensive defaults.\n/// @param digit Character that may describe a '0'/'1' flag or other sentinel input.\n/// @return True/false according to the learner-defined mapping, defaulting safely for invalid chars.\n/// @note Learners must guard against undefined behavior by validating digits before deduction.\nbool boolFlagFromChar(char digit);\n\n/// Connects `std::optional` with explicit character outputs to avoid implicit bool-to-char casts.\n/// @param flag Optional boolean sourced from diagnostics or configuration data.\n/// @return 'T'/'F' (or a learner-chosen fallback) conveying the optional state without ambiguity.\n/// @note Learners must cover engaged/empty optionals and document how auto interacts with conditionals.\nchar charFromBool(const std::optional<bool>& flag);\n\n}  // namespace type_workshop\n",
      "is_complete": false,
      "next_focus": "type_workshop.cpp"
    }
  ],
  "next_focus": "type_workshop.cpp"
}