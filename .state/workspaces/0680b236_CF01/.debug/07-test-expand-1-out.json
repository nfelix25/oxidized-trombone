{
  "accepted": true,
  "schemaName": "test_section_v1",
  "payload": {
    "schema_version": "test_section_v1",
    "role": "test-expand",
    "section_id": "type_workshop_tests",
    "type": "code",
    "file_path": "type_workshop_tests.cpp",
    "content": "#include <gtest/gtest.h>\n#include \"solution.h\"\n#include <limits>\n#include <optional>\n#include <stdexcept>\n#include <string>\n#include <type_traits>\n\nnamespace {\nstruct BaseFlag {\n  int id = 0;\n  virtual ~BaseFlag() = default;\n};\n\nstruct DerivedFlag : BaseFlag {\n  int extra = 0;\n  DerivedFlag(int base_value, int extra_value) {\n    id = base_value;\n    extra = extra_value;\n  }\n};\n}  // namespace\n\nTEST(InferSumType, IntAndDoublePromotesToDouble) {\n  auto result = type_workshop::inferSumType(4, 2.5);\n  EXPECT_TRUE((std::is_same_v<decltype(result), double>));\n  EXPECT_DOUBLE_EQ(result, 6.5);\n}\n\nTEST(InferSumType, IntPairStaysInteger) {\n  auto result = type_workshop::inferSumType(3, 5);\n  EXPECT_TRUE((std::is_same_v<decltype(result), int>));\n  EXPECT_EQ(result, 8);\n}\n\nTEST(InferSumType, HandlesLargeIntegersSafely) {\n  const long long near_max = std::numeric_limits<long long>::max() - 1;\n  auto result = type_workshop::inferSumType(near_max, 1LL);\n  EXPECT_TRUE((std::is_same_v<decltype(result), long long>));\n  EXPECT_EQ(result, std::numeric_limits<long long>::max());\n}\n\nTEST(PreserveConstRef, ReturnsConstReferenceWithoutSlicing) {\n  const DerivedFlag derived(42, 99);\n  const auto& ref = type_workshop::preserveConstRef(derived);\n  EXPECT_EQ(&ref, &derived);\n  const BaseFlag& base_view = ref;\n  EXPECT_EQ(base_view.id, 42);\n  EXPECT_EQ(ref.extra, 99);\n}\n\nTEST(PreserveConstRef, RejectsTemporaries) {\n  EXPECT_THROW(\n      {\n        const auto& ref =\n            type_workshop::preserveConstRef(std::string{\"temporary\"});\n        (void)ref;\n      },\n      std::logic_error);\n}\n\nTEST(PreserveConstRef, KeepsVolatileQualifier) {\n  volatile int counter = 7;\n  const volatile int& ref = type_workshop::preserveConstRef(counter);\n  EXPECT_TRUE((std::is_same_v<decltype(ref), const volatile int&>));\n  counter = 11;\n  EXPECT_EQ(ref, 11);\n}\n\nTEST(BoolFlagFromChar, ZeroIsFalseOneIsTrue) {\n  EXPECT_FALSE(type_workshop::boolFlagFromChar('0'));\n  EXPECT_TRUE(type_workshop::boolFlagFromChar('1'));\n}\n\nTEST(BoolFlagFromChar, NonDigitsUseSafeDefault) {\n  EXPECT_FALSE(type_workshop::boolFlagFromChar('x'));\n  EXPECT_FALSE(type_workshop::boolFlagFromChar('/'));\n}\n\nTEST(CharFromBool, UsesExplicitLetters) {\n  EXPECT_EQ(type_workshop::charFromBool(std::optional<bool>{true}), 'T');\n  EXPECT_EQ(type_workshop::charFromBool(std::optional<bool>{false}), 'F');\n}\n\nTEST(CharFromBool, HandlesEmptyOptionalWithFallback) {\n  EXPECT_EQ(type_workshop::charFromBool(std::nullopt), '?');\n}\n",
    "is_complete": true,
    "next_focus": ""
  }
}