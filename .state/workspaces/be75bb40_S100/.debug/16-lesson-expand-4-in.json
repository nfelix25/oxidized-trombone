{
  "schema_version": "context_packet_v1",
  "packet_id": "7cc1f11f-ec0b-4d70-bf12-5452e6190266",
  "timestamp_utc": "2026-02-24T23:11:02.917Z",
  "role": "lesson-expand",
  "task_type": "lesson_expand",
  "learner_profile": {
    "masteryLevel": 0
  },
  "curriculum_context": {
    "node_id": "S100",
    "depth_target": "D1"
  },
  "misconception_context": {
    "top_tags": []
  },
  "attempt_context": null,
  "evidence_context": null,
  "policy_context": {
    "allow_reveal": false
  },
  "memory_context": {},
  "scaffold_context": {
    "scaffold_id": "scaffold-S100-D1-v1",
    "exercise_description": "Design a mini smart-home metrics toolkit that reinforces Rust variable declarations, mutability, constants, and type inference across integers, floats, tuples, and bools, culminating in comparisons between mutation and shadowing before leading into control flow.",
    "lesson_plan": {
      "section_intents": [
        "Spark interest with a story about modeling a smart thermostat’s daily report to motivate precise variable control.",
        "Establish fundamentals of `let`, `mut`, and `const`, highlighting Rust’s default immutability and type inference rules.",
        "Worked example 1: walk through modeling daily temperature readings using `let` bindings with explicit vs inferred integer/float types.",
        "Worked example 2: refactor an energy-budget tracker to show when to choose `mut`, when to shadow, and how constants keep invariants static.",
        "Surface common pitfalls such as forgetting `mut`, mixing signed/unsigned integers, or misusing `_` placeholders for unused bindings.",
        "Comparison spotlight: contrast mutation with shadowing using scoped demos to clarify safety trade-offs and typical use cases.",
        "Bridge forward by previewing how these bindings feed into control-flow patterns (loops/conditionals) tackled in the next lesson."
      ]
    },
    "starter_plan": {
      "file_intents": [
        "src/bindings.rs: add 3-4 function stubs (`define_city_population`, `toggle_alarm_state`, `compute_interest_rate`) covering basic `let`/`mut` primitives.",
        "src/shadowing.rs: add 3 scoped demo stubs (`shadow_temperature_reading`, `redeclare_unit_label`, `scoped_counter_demo`) illustrating shadowing vs mutation choices.",
        "src/types.rs: add 3-4 stubs (`sum_mixed_integers`, `split_tuple_components`, `const_planck_ratio`) focused on explicit type annotations, tuples, and units."
      ]
    },
    "test_plan": {
      "case_intents": [
        "`define_city_population` returns an immutable `i32` matching the expected city sample when called with no args.",
        "`toggle_alarm_state` flips a mutable boolean and toggling twice restores the original value (property-style).",
        "`compute_interest_rate` uses `f64` math to produce a precise fractional rate within a 1e-6 tolerance.",
        "`shadow_temperature_reading` demonstrates that shadowed bindings can change type without mutability errors.",
        "`redeclare_unit_label` handles an edge-case Unicode-like char by constraining to ASCII and proving the label resets safely (edge case).",
        "`scoped_counter_demo` shows an inner mutable counter that doesn’t leak mutations to the outer scope.",
        "`sum_mixed_integers` safely adds signed `i32` and unsigned `u64` inputs without overflow for provided fixtures.",
        "`split_tuple_components` destructures a `(char, bool, f64)` tuple and returns each component in order.",
        "`const_planck_ratio` exposes a `const` binding that stays accessible across calls and matches the expected `f64` literal."
      ]
    }
  },
  "prior_loop_sections": [
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "bindings.rs",
      "type": "file",
      "file_path": "bindings.rs",
      "content": "// Smart-home binding demos for the exercise crate.\n\n/// Demonstrates Rust's default immutability with `let` bindings and type inference.\n/// Implementers should return the sample city's population as an `i32` without using `mut`.\npub fn define_city_population() -> i32 {\n    // Bind an immutable population value with `let` and return it directly.\n    todo!()\n}\n\n/// Highlights when `mut` is required to flip a boolean smart-home alarm state.\n/// Implementers should toggle the state twice to prove mutations happen in a scoped, reversible way.\npub fn toggle_alarm_state(initial_state: bool) -> bool {\n    // Make a mutable copy of the alarm state, flip it, then flip it back to demonstrate control.\n    todo!()\n}\n\n/// Reinforces explicit `f64` math with `let`, constants, and inferred temporaries for interest calculations.\n/// Implementers should compute `(gain / principal)` with double precision and illustrate why `mut` is unnecessary.\npub fn compute_interest_rate(principal: f64, gain: f64) -> f64 {\n    // Use precise floating-point bindings (and optional consts) to derive the fractional interest rate.\n    todo!()\n}\n",
      "is_complete": false,
      "next_focus": "shadowing.rs"
    },
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "shadowing.rs",
      "type": "file",
      "file_path": "shadowing.rs",
      "content": "// Shadowing demos to compare mutation and redeclaration patterns.\n\n/// Shows how to shadow an immutable temperature binding to change both value and type without requiring `mut`.\n/// Implementers should return the original Celsius reading plus a formatted Fahrenheit summary derived via shadowing.\npub fn shadow_temperature_reading(reading_celsius: f64) -> (f64, String) {\n    // Capture the initial immutable reading, then shadow it with converted forms to illustrate type swapping.\n    todo!()\n}\n\n/// Demonstrates safe redeclaration of a unit label inside a narrow scope to enforce ASCII-only characters.\n/// Implementers should shadow the label to sanitize non-ASCII input while proving the outer binding remains unchanged.\npub fn redeclare_unit_label(raw_label: &str) -> (String, String) {\n    // Keep the original immutable label, then shadow it with a cleaned ASCII variant that the function returns.\n    todo!()\n}\n\n/// Contrasts mutation and shadowing by keeping an outer immutable counter while an inner scope mutates its own copy.\n/// Implementers should return the untouched outer count alongside the inner mutable tally to highlight isolation.\npub fn scoped_counter_demo(start: i32) -> (i32, i32) {\n    // Bind an outer count, shadow it in an inner scope with a mutable version, and expose both results.\n    todo!()\n}\n",
      "is_complete": false,
      "next_focus": "types.rs"
    },
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "types.rs",
      "type": "file",
      "file_path": "types.rs",
      "content": "// Type and tuple demos for the exercise crate.\n\n/// Demonstrates explicit integer annotations and conversions when mixing signed and unsigned energy data.\n/// Implementers should add the signed delta to the unsigned baseline using safe casting that preserves totals.\npub fn sum_mixed_integers(delta_signed: i32, baseline_unsigned: u64) -> u64 {\n    // Combine i32 and u64 values via deliberate casting choices to avoid overflow surprises.\n    todo!()\n}\n\n/// Highlights tuple destructuring with annotated element types and underscores for unused bindings.\n/// Implementers should destructure a `(char, bool, f64)` packet and return the pieces exactly as received to reinforce ownership.\npub fn split_tuple_components(packet: (char, bool, f64)) -> (char, bool, f64) {\n    // Break the tuple apart with pattern matching before reassembling the values for the caller.\n    todo!()\n}\n\n/// Reinforces `const` bindings with `f64` precision and shows they remain accessible across calls.\n/// Implementers should expose a smart-home Planck ratio constant and return it as a double-precision literal without mutation.\npub fn const_planck_ratio() -> f64 {\n    // Declare a descriptive `const` and hand the literal back directly to prove immutability.\n    todo!()\n}\n",
      "is_complete": true,
      "next_focus": ""
    },
    {
      "schema_version": "test_section_v1",
      "role": "test-expand",
      "section_id": "bindings_shadowing_types.rs",
      "type": "file",
      "file_path": "bindings_shadowing_types.rs",
      "content": "use exercise::bindings::{compute_interest_rate, define_city_population, toggle_alarm_state};\nuse exercise::shadowing::{redeclare_unit_label, scoped_counter_demo, shadow_temperature_reading};\nuse exercise::types::{const_planck_ratio, split_tuple_components, sum_mixed_integers};\n\nconst EXPECTED_CITY_POPULATION: i32 = 915_000;\nconst EXPECTED_PLANCK_RATIO: f64 = 6.626_070_15e-34;\n\n#[test]\nfn define_city_population_matches_story_sample() {\n    let population = define_city_population();\n    assert_eq!(population, EXPECTED_CITY_POPULATION, \"Sample city population should remain immutable and match the story-driven constant.\");\n}\n\n#[test]\nfn toggle_alarm_state_round_trip_property() {\n    for &initial in &[true, false] {\n        let restored = toggle_alarm_state(initial);\n        assert_eq!(restored, initial, \"Toggling the alarm twice should restore the original state for {:?}\", initial);\n    }\n}\n\n#[test]\nfn compute_interest_rate_precision_within_tolerance() {\n    let principal = 2500.0;\n    let gain = 137.5;\n    let rate = compute_interest_rate(principal, gain);\n    let expected = gain / principal;\n    let delta = (rate - expected).abs();\n    assert!(delta <= 1e-6, \"Computed rate should match {:.6} within tolerance, delta was {}\", expected, delta);\n    assert!(rate > 0.0, \"Interest rate should remain positive for positive gain scenarios.\");\n}\n\n#[test]\nfn shadow_temperature_reading_infers_new_type_without_mut() {\n    let reading = 21.5;\n    let (celsius, summary) = shadow_temperature_reading(reading);\n    assert_eq!(celsius, reading, \"Original Celsius reading should be preserved as the first tuple item.\");\n    let expected_fahrenheit = reading * 9.0 / 5.0 + 32.0;\n    let formatted_fahrenheit = format!(\"{:.1}\", expected_fahrenheit);\n    assert!(summary.contains(&formatted_fahrenheit), \"Summary should include the Fahrenheit value {}, but was {}\", formatted_fahrenheit, summary);\n    assert!(summary.contains('F'), \"Summary should mention Fahrenheit to highlight the type change.\");\n}\n\n#[test]\nfn redeclare_unit_label_sanitizes_non_ascii_edge_case() {\n    let raw = \"°C-zone\";\n    let (original, sanitized) = redeclare_unit_label(raw);\n    assert_eq!(original, raw, \"Original raw label should remain unchanged to prove the outer binding's immutability.\");\n    assert!(sanitized.is_ascii(), \"Sanitized label should consist solely of ASCII characters, but '{}' was returned.\", sanitized);\n    assert!(sanitized.contains(\"C\"), \"Sanitized label should keep a recognizable ASCII unit marker, received {}\", sanitized);\n    assert_ne!(sanitized, original, \"Sanitized label should differ from the raw label when Unicode glyphs are removed.\");\n}\n\n#[test]\nfn scoped_counter_demo_isolates_mutation_in_inner_scope() {\n    let start = 3;\n    let (outer, inner) = scoped_counter_demo(start);\n    assert_eq!(outer, start, \"Outer immutable counter should remain {} even after inner scope mutations.\", start);\n    assert!(inner > outer, \"Inner mutable counter should exceed the outer value to prove scoped mutation, got {}\", inner);\n}\n\n#[test]\nfn sum_mixed_integers_handles_signed_and_unsigned_pairs() {\n    let case_one = sum_mixed_integers(-50, 200);\n    assert_eq!(case_one, 150, \"Unsigned result should subtract signed delta without underflow for baseline 200.\");\n    let case_two = sum_mixed_integers(125, 1_000);\n    assert_eq!(case_two, 1_125, \"Unsigned result should include positive signed delta for baseline 1_000.\");\n    assert!(case_one <= case_two, \"Results should remain ordered with respect to the signed deltas applied.\");\n}\n\n#[test]\nfn split_tuple_components_returns_original_packet_order() {\n    let packet = ('A', true, 42.5);\n    let (c, flag, value) = split_tuple_components(packet);\n    assert_eq!(c, packet.0, \"Returned char component should match the input tuple's first element.\");\n    assert_eq!(flag, packet.1, \"Returned bool component should match the input tuple's second element.\");\n    assert_eq!(value, packet.2, \"Returned f64 component should match the input tuple's third element.\");\n}\n\n#[test]\nfn const_planck_ratio_matches_expected_literal_across_calls() {\n    let first = const_planck_ratio();\n    let second = const_planck_ratio();\n    assert_eq!(first, EXPECTED_PLANCK_RATIO, \"First access should return the declared Planck ratio literal.\");\n    assert_eq!(second, EXPECTED_PLANCK_RATIO, \"Second access should return the same Planck ratio literal.\");\n    assert_eq!(first, second, \"Subsequent reads of the const should match exactly.\");\n}\n",
      "is_complete": true,
      "next_focus": ""
    }
  ],
  "current_sections": [
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "section-1",
      "type": "concept",
      "content": "Imagine your smart thermostat, ThermoTrack-7, trying to brief you on a blustery February day in Denver. It has just three seconds to capture the morning chill, the toastier afternoon bump, and a cautious humidity reading before deciding whether to preheat the living room or kick on the dehumidifier. If any of those readings wobble—say the afternoon warmth mistakenly overwrites the morning baseline—the whole schedule drifts, wasting energy just when you needed precision. Telling this story in Rust forces us to treat every snapshot as a deliberate binding, not a casual log entry.\n```rust\nlet morning_celsius: f64 = 19.5;            // immutable anchor for the daily baseline\nlet afternoon_celsius = morning_celsius + 2.3; // inferred f64, derived from the baseline\nlet humidity_percent: u8 = 42;               // discrete sensor channel with explicit bounds\nlet report = format!(\n    \"ThermoTrack-7 report -> morning: {:.1}°C, afternoon: {:.1}°C, humidity: {}%\",\n    morning_celsius,\n    afternoon_celsius,\n    humidity_percent\n);\nprintln!(\"{report}\");\n```\nThat single printout hints at the discipline we’ll practice next: guarding immutable facts, opting into mutation only when the story demands a new event, and trusting Rust’s type inference to keep every metric honest before we graduate into full control-flow routines.",
      "is_complete": false,
      "next_focus": "Establish fundamentals of `let`, `mut`, and `const`, highlighting Rust’s default immutability and type inference rules."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "section-2",
      "type": "concept",
      "content": "Before ThermoTrack-7 crunches reports, we must tame Rust’s vocabulary for binding values. The keyword `let` creates bindings that are *immutable by default*, meaning a morning calibration like `let baseline = 19.5;` cannot be overwritten unless we explicitly opt in with `mut`. That default acts like a safety interlock: if you try to reuse a variable name without shadowing or `mut`, the compiler refuses to compile, catching accidental overwrites before they hit the HVAC hardware. When we genuinely expect a value to evolve—say, accumulating kilowatt-hours over the day—we mark it `let mut energy_used = 0_f64;` so that intent is visible in code review. Constants, introduced with `const`, go a step further by demanding type annotations and becoming globally accessible invariants, perfect for fixed sample sizes or maximum duty cycles. Rust’s type inference fills in the rest; as long as the compiler sees enough information on the right-hand side, `let humidity_percent = 42u8;` needs no explicit type. Putting these pieces together feels like wiring a control panel: each binding has a clear role, the mutable ones are labeled as such, and the constants keep every module aligned on shared constraints.\n```rust\nconst MAX_DAILY_LOGS: usize = 96; // 24 hours × 4 readings per hour\n\nfn prepare_metrics() {\n    let calibration_celsius: f64 = 19.5; // explicit type for clarity\n    let mut energy_used = 0.0;          // inferred f64, but mutable for accumulation\n    energy_used += 1.25;\n    println!(\"baseline={calibration_celsius}, energy={energy_used}, slots={MAX_DAILY_LOGS}\");\n}\n```\nThis trio—`let`, `mut`, and `const`—forms the contract every later control-flow structure depends on.",
      "is_complete": false,
      "next_focus": "Worked example 1: walk through modeling daily temperature readings using `let` bindings with explicit vs inferred integer/float types."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "section-3",
      "type": "worked_example",
      "content": "ThermoTrack-7’s daily summary starts with a crisp pair of temperature streams: the furnace feed relays integers from a coarse sensor every hour, while the precision unit tracks decimals for comfort tuning. Start by anchoring both data sources with the right binding styles.\n```rust\nfn summarize_day() {\n    // Explicit integer typing keeps coarse readings predictable for bit-packed storage.\n    let morning_floor_celsius: i16 = 18; // lowest safe floor temp (°C)\n    let evening_floor_celsius: i16 = 22;\n\n    // Inferred floats capture nuanced swings without extra syntax noise.\n    let morning_room = 18.7_f32;\n    let afternoon_room = morning_room + 2.1; // still f32 by inference\n    let evening_room = afternoon_room - 0.4;\n\n    // Compute spans to surface deltas for downstream alerts.\n    let floor_delta = evening_floor_celsius - morning_floor_celsius; // i16 math\n    let room_delta = evening_room - morning_room; // f32 math\n\n    println!(\n        \"Floor delta: {floor_delta}°C, Room delta: {room_delta:.1}°C\"\n    );\n}\n```\nEvery `let` communicates intent: the coarse readings force an explicit `i16` so maintenance engineers know the sensor’s range, while the room values lean on inference to emphasize the flow of calculations rather than their types. Running `summarize_day()` prints the precise swing for both channels, reinforcing how Rust lets you mix explicitness and inference without sacrificing safety. Encourage learners to tweak the literals (say, simulate a cold snap) and watch the compiler keep integer math separated from floating-point adjustments—exactly the discipline a smart-home report needs before layering on stateful `mut` bindings in later examples.",
      "is_complete": false,
      "next_focus": "Worked example 2: refactor an energy-budget tracker to show when to choose `mut`, when to shadow, and how constants keep invariants static."
    }
  ],
  "next_focus": "Worked example 2: refactor an energy-budget tracker to show when to choose `mut`, when to shadow, and how constants keep invariants static."
}