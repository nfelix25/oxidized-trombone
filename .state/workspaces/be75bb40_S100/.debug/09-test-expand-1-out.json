{
  "accepted": true,
  "schemaName": "test_section_v1",
  "payload": {
    "schema_version": "test_section_v1",
    "role": "test-expand",
    "section_id": "bindings_shadowing_types.rs",
    "type": "file",
    "file_path": "bindings_shadowing_types.rs",
    "content": "use exercise::bindings::{compute_interest_rate, define_city_population, toggle_alarm_state};\nuse exercise::shadowing::{redeclare_unit_label, scoped_counter_demo, shadow_temperature_reading};\nuse exercise::types::{const_planck_ratio, split_tuple_components, sum_mixed_integers};\n\nconst EXPECTED_CITY_POPULATION: i32 = 915_000;\nconst EXPECTED_PLANCK_RATIO: f64 = 6.626_070_15e-34;\n\n#[test]\nfn define_city_population_matches_story_sample() {\n    let population = define_city_population();\n    assert_eq!(population, EXPECTED_CITY_POPULATION, \"Sample city population should remain immutable and match the story-driven constant.\");\n}\n\n#[test]\nfn toggle_alarm_state_round_trip_property() {\n    for &initial in &[true, false] {\n        let restored = toggle_alarm_state(initial);\n        assert_eq!(restored, initial, \"Toggling the alarm twice should restore the original state for {:?}\", initial);\n    }\n}\n\n#[test]\nfn compute_interest_rate_precision_within_tolerance() {\n    let principal = 2500.0;\n    let gain = 137.5;\n    let rate = compute_interest_rate(principal, gain);\n    let expected = gain / principal;\n    let delta = (rate - expected).abs();\n    assert!(delta <= 1e-6, \"Computed rate should match {:.6} within tolerance, delta was {}\", expected, delta);\n    assert!(rate > 0.0, \"Interest rate should remain positive for positive gain scenarios.\");\n}\n\n#[test]\nfn shadow_temperature_reading_infers_new_type_without_mut() {\n    let reading = 21.5;\n    let (celsius, summary) = shadow_temperature_reading(reading);\n    assert_eq!(celsius, reading, \"Original Celsius reading should be preserved as the first tuple item.\");\n    let expected_fahrenheit = reading * 9.0 / 5.0 + 32.0;\n    let formatted_fahrenheit = format!(\"{:.1}\", expected_fahrenheit);\n    assert!(summary.contains(&formatted_fahrenheit), \"Summary should include the Fahrenheit value {}, but was {}\", formatted_fahrenheit, summary);\n    assert!(summary.contains('F'), \"Summary should mention Fahrenheit to highlight the type change.\");\n}\n\n#[test]\nfn redeclare_unit_label_sanitizes_non_ascii_edge_case() {\n    let raw = \"Â°C-zone\";\n    let (original, sanitized) = redeclare_unit_label(raw);\n    assert_eq!(original, raw, \"Original raw label should remain unchanged to prove the outer binding's immutability.\");\n    assert!(sanitized.is_ascii(), \"Sanitized label should consist solely of ASCII characters, but '{}' was returned.\", sanitized);\n    assert!(sanitized.contains(\"C\"), \"Sanitized label should keep a recognizable ASCII unit marker, received {}\", sanitized);\n    assert_ne!(sanitized, original, \"Sanitized label should differ from the raw label when Unicode glyphs are removed.\");\n}\n\n#[test]\nfn scoped_counter_demo_isolates_mutation_in_inner_scope() {\n    let start = 3;\n    let (outer, inner) = scoped_counter_demo(start);\n    assert_eq!(outer, start, \"Outer immutable counter should remain {} even after inner scope mutations.\", start);\n    assert!(inner > outer, \"Inner mutable counter should exceed the outer value to prove scoped mutation, got {}\", inner);\n}\n\n#[test]\nfn sum_mixed_integers_handles_signed_and_unsigned_pairs() {\n    let case_one = sum_mixed_integers(-50, 200);\n    assert_eq!(case_one, 150, \"Unsigned result should subtract signed delta without underflow for baseline 200.\");\n    let case_two = sum_mixed_integers(125, 1_000);\n    assert_eq!(case_two, 1_125, \"Unsigned result should include positive signed delta for baseline 1_000.\");\n    assert!(case_one <= case_two, \"Results should remain ordered with respect to the signed deltas applied.\");\n}\n\n#[test]\nfn split_tuple_components_returns_original_packet_order() {\n    let packet = ('A', true, 42.5);\n    let (c, flag, value) = split_tuple_components(packet);\n    assert_eq!(c, packet.0, \"Returned char component should match the input tuple's first element.\");\n    assert_eq!(flag, packet.1, \"Returned bool component should match the input tuple's second element.\");\n    assert_eq!(value, packet.2, \"Returned f64 component should match the input tuple's third element.\");\n}\n\n#[test]\nfn const_planck_ratio_matches_expected_literal_across_calls() {\n    let first = const_planck_ratio();\n    let second = const_planck_ratio();\n    assert_eq!(first, EXPECTED_PLANCK_RATIO, \"First access should return the declared Planck ratio literal.\");\n    assert_eq!(second, EXPECTED_PLANCK_RATIO, \"Second access should return the same Planck ratio literal.\");\n    assert_eq!(first, second, \"Subsequent reads of the const should match exactly.\");\n}\n",
    "is_complete": true,
    "next_focus": ""
  }
}