{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "section-5",
    "type": "pitfalls",
    "content": "ThermoTrack-7 stumbles whenever we forget which bindings are allowed to morph or how Rust guards type boundaries. First, the classic missing `mut`: we try to keep a running humidity tally, but the compiler refuses to let an immutable binding change.\n```rust\nfn bump_humidity(readings: &[u8]) -> u8 {\n    let total = readings[0];\n    total += 5; // ❌ attempt to mutate an immutable binding\n    total\n}\n```\n```\nerror[E0596]: cannot borrow `total` as mutable, as it is not declared as mutable\n```\nFix it by marking intentional state with `mut` while leaving the slice itself immutable.\n```rust\nlet mut total = readings[0];\nfor &delta in &readings[1..] {\n    total += delta;\n}\n```\nNext, mixing signed and unsigned energy numbers can silently wrap if you coerce the wrong way.\n```rust\nlet baseline: u64 = 800;\nlet delta: i32 = -150;\nlet net = baseline + delta; // ❌ type mismatch\n```\n```\nerror[E0277]: cannot add `i32` to `u64`\n```\nDecide the final storage type, then cast deliberately: `let net = baseline as i64 + delta as i64;`. Finally, underscores only discard data; they can’t be re-used later.\n```rust\nlet _ = sensor_packet();\nprintln!(\"{}\", _); // ❌ `_` has no value to print\n```\n```\nerror[E0412]: cannot find value `_` in this scope\n```\nEither keep the binding (`let packet = sensor_packet();`) or use a descriptive `_packet` when you truly ignore it. Keeping these guardrails straight prevents bogus metrics from ever leaving the thermostat’s brain.",
    "is_complete": false,
    "next_focus": "Comparison spotlight: contrast mutation with shadowing using scoped demos to clarify safety trade-offs and typical use cases."
  }
}