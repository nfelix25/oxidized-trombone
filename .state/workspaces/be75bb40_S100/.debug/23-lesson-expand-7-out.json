{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "section-7",
    "type": "bridge",
    "content": "Our bindings now feel trustworthy, so the final step is wiring them into the decision engines ThermoTrack-7 needs tomorrow: loops, conditionals, and matches that react to evolving sensor streams. Imagine sampling every hallway probe, mutating only the aggregates while shadowing presentation layers right before control flow branches.\n```rust\nconst TARGET_HUMIDITY: f32 = 45.0;\n\nfn prep_for_control(readings: &[f32]) {\n    let mut rolling_avg = 0.0; // mutable because each loop iteration refines the state\n    for (idx, &reading) in readings.iter().enumerate() {\n        rolling_avg = (rolling_avg * idx as f32 + reading) / (idx as f32 + 1.0);\n        let status = if reading > TARGET_HUMIDITY { \"dehumidify\" } else { \"hold\" };\n        println!(\"reading {idx}: {reading:.1}% -> {status}\");\n    }\n\n    let summary = format!(\"avg {:.1}%\", rolling_avg);\n    let summary = summary.to_uppercase(); // shadow to change representation without mutating the string buffer\n\n    match rolling_avg {\n        avg if avg > TARGET_HUMIDITY + 5.0 => println!(\"{summary} | schedule extra vent purge\"),\n        avg if avg < TARGET_HUMIDITY - 5.0 => println!(\"{summary} | humidifier boost\"),\n        _ => println!(\"{summary} | stay steady\"),\n    }\n}\n```\nThe `for` loop consumes immutable sensor slices while a single `mut` binding tracks the rolling average. Each `if` gate illustrates how comparisons hinge on earlier constants, and the `match` prepares learners for branching logic that will soon orchestrate fans and vents. By the next lesson, these disciplined bindings will drive `while`, `loop`, and `match` constructs that automate the thermostatâ€™s reactions without ever losing control of the underlying data stories.",
    "is_complete": true,
    "next_focus": ""
  }
}