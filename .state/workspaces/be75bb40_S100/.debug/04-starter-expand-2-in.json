{
  "schema_version": "context_packet_v1",
  "packet_id": "b2e12667-32c1-4f6f-bd2d-8da88fab2fb7",
  "timestamp_utc": "2026-02-24T23:09:13.167Z",
  "role": "starter-expand",
  "task_type": "starter_expand",
  "learner_profile": {
    "masteryLevel": 0
  },
  "curriculum_context": {
    "node_id": "S100",
    "depth_target": "D1"
  },
  "misconception_context": {
    "top_tags": []
  },
  "attempt_context": null,
  "evidence_context": null,
  "policy_context": {
    "allow_reveal": false
  },
  "memory_context": {},
  "scaffold_context": {
    "scaffold_id": "scaffold-S100-D1-v1",
    "exercise_description": "Design a mini smart-home metrics toolkit that reinforces Rust variable declarations, mutability, constants, and type inference across integers, floats, tuples, and bools, culminating in comparisons between mutation and shadowing before leading into control flow.",
    "lesson_plan": {
      "section_intents": [
        "Spark interest with a story about modeling a smart thermostat’s daily report to motivate precise variable control.",
        "Establish fundamentals of `let`, `mut`, and `const`, highlighting Rust’s default immutability and type inference rules.",
        "Worked example 1: walk through modeling daily temperature readings using `let` bindings with explicit vs inferred integer/float types.",
        "Worked example 2: refactor an energy-budget tracker to show when to choose `mut`, when to shadow, and how constants keep invariants static.",
        "Surface common pitfalls such as forgetting `mut`, mixing signed/unsigned integers, or misusing `_` placeholders for unused bindings.",
        "Comparison spotlight: contrast mutation with shadowing using scoped demos to clarify safety trade-offs and typical use cases.",
        "Bridge forward by previewing how these bindings feed into control-flow patterns (loops/conditionals) tackled in the next lesson."
      ]
    },
    "starter_plan": {
      "file_intents": [
        "src/bindings.rs: add 3-4 function stubs (`define_city_population`, `toggle_alarm_state`, `compute_interest_rate`) covering basic `let`/`mut` primitives.",
        "src/shadowing.rs: add 3 scoped demo stubs (`shadow_temperature_reading`, `redeclare_unit_label`, `scoped_counter_demo`) illustrating shadowing vs mutation choices.",
        "src/types.rs: add 3-4 stubs (`sum_mixed_integers`, `split_tuple_components`, `const_planck_ratio`) focused on explicit type annotations, tuples, and units."
      ]
    },
    "test_plan": {
      "case_intents": [
        "`define_city_population` returns an immutable `i32` matching the expected city sample when called with no args.",
        "`toggle_alarm_state` flips a mutable boolean and toggling twice restores the original value (property-style).",
        "`compute_interest_rate` uses `f64` math to produce a precise fractional rate within a 1e-6 tolerance.",
        "`shadow_temperature_reading` demonstrates that shadowed bindings can change type without mutability errors.",
        "`redeclare_unit_label` handles an edge-case Unicode-like char by constraining to ASCII and proving the label resets safely (edge case).",
        "`scoped_counter_demo` shows an inner mutable counter that doesn’t leak mutations to the outer scope.",
        "`sum_mixed_integers` safely adds signed `i32` and unsigned `u64` inputs without overflow for provided fixtures.",
        "`split_tuple_components` destructures a `(char, bool, f64)` tuple and returns each component in order.",
        "`const_planck_ratio` exposes a `const` binding that stays accessible across calls and matches the expected `f64` literal."
      ]
    }
  },
  "prior_loop_sections": [],
  "current_sections": [
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "bindings.rs",
      "type": "file",
      "file_path": "bindings.rs",
      "content": "// Smart-home binding demos for the exercise crate.\n\n/// Demonstrates Rust's default immutability with `let` bindings and type inference.\n/// Implementers should return the sample city's population as an `i32` without using `mut`.\npub fn define_city_population() -> i32 {\n    // Bind an immutable population value with `let` and return it directly.\n    todo!()\n}\n\n/// Highlights when `mut` is required to flip a boolean smart-home alarm state.\n/// Implementers should toggle the state twice to prove mutations happen in a scoped, reversible way.\npub fn toggle_alarm_state(initial_state: bool) -> bool {\n    // Make a mutable copy of the alarm state, flip it, then flip it back to demonstrate control.\n    todo!()\n}\n\n/// Reinforces explicit `f64` math with `let`, constants, and inferred temporaries for interest calculations.\n/// Implementers should compute `(gain / principal)` with double precision and illustrate why `mut` is unnecessary.\npub fn compute_interest_rate(principal: f64, gain: f64) -> f64 {\n    // Use precise floating-point bindings (and optional consts) to derive the fractional interest rate.\n    todo!()\n}\n",
      "is_complete": false,
      "next_focus": "shadowing.rs"
    }
  ],
  "next_focus": "shadowing.rs"
}