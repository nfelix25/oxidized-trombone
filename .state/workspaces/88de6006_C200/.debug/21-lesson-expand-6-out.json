{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "sec-restrict-memcpy",
    "type": "concept",
    "content": "`restrict` tells the compiler that, for the lifetime of a pointer, no other pointer will access the same storage. When you decorate memcpy-style helpers with `restrict`, you are promising the same non-overlap preconditions that POSIXâ€™s `memcpy()` requires, letting the optimizer vectorize loads and stores without inserting defensive reloads. In contrast, `memmove()` can tolerate aliases, so it cannot take advantage of `restrict`. The contract matters most inside throughput-critical buffer shuttles where every redundant read burns cache bandwidth. The helper below mirrors the guarantees `read()` consumers often need: the destination and source byte ranges never overlap, the byte count is explicit, and we can compile with `-O3` confident that the compiler will not assume aliasing between `dst` and `src`.\n```c\n#include <string.h>\n#include <stddef.h>\n#include <errno.h>\n\nint copy_frame(void *restrict dst,\n               const void *restrict src,\n               size_t len)\n{\n    const unsigned char *s = src;\n    unsigned char *d = dst;\n    if (!dst || !src) {\n        return EINVAL;\n    }\n    if ((d <= s && d + len > s) || (s <= d && s + len > d)) {\n        return EOVERFLOW; /* would violate restrict */\n    }\n    memcpy(d, s, len);\n    return 0;\n}\n```\nBy policing overlaps up front, the function keeps the `restrict` promise intact, matching the model of high-speed logging daemons that copy snapshot buffers into disjoint ring slots before dispatching to worker threads.",
    "is_complete": false,
    "next_focus": "Contrast const pointer vs pointer-to-const: demonstrate composing const-correct wrappers over read-only shared memory."
  }
}