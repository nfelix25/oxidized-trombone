{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "sec-typed-vs-void",
    "type": "comparison",
    "content": "Typed pointers bake element size into every addition, while `void *` is a byte-address only after you cast it. ISO C prohibits arithmetic directly on `void *`, so POSIX interfaces that traffic in erased addresses (`read()`, `write()`, `aio_read()`) require you to cast back to a concrete type before incrementing. The upside of typed pointers is stride safety: advancing `int *` by `+1` always skips exactly `sizeof(int)` bytes, which matches how kernel-filled sensor frames are laid out. The erased `void *` view shines when the same pointer must hop between APIs with differing element types, but you must manually scale offsets. Importantly, qualifiers survive the round-trip: casting `const void *` to `const uint8_t *` preserves immutability, and the `restrict` promise continues to hold so long as you do not create overlapping aliases after the cast.\n```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid demo(const void *restrict raw, size_t len)\n{\n    const uint8_t *restrict bytes = raw;      /* preserves const+restrict */\n    for (size_t i = 0; i < len; ++i) {\n        uint8_t value = bytes[i];             /* typed stride == 1 byte */\n        consume(value);\n    }\n\n    const uint8_t *cursor = (const uint8_t *)raw;\n    const uint8_t *end = cursor + len;        /* arithmetic now legal */\n    const void *one_past = (const void *)end; /* erase again for POSIX */\n    submit_buffer(one_past, len);             /* still honors qualifiers */\n}\n```\nWhenever you must compute byte offsets before reintroducing type, cast the `void *` to `unsigned char *` (the only type guaranteed to address individual bytes), perform the arithmetic there, and then cast to the eventual element type. That keeps arithmetic defined while maintaining `const` and `restrict` guarantees across conversions.",
    "is_complete": false,
    "next_focus": "Bridge forward: preview how these pointer guarantees enable safer buffer pools and ownership models in upcoming memory-management lessons."
  }
}