{
  "schema_version": "context_packet_v1",
  "packet_id": "23b2b7df-eea8-4eab-be89-a8a9a96c66c4",
  "timestamp_utc": "2026-02-24T20:14:12.438Z",
  "role": "lesson-expand",
  "task_type": "lesson_expand",
  "learner_profile": {
    "masteryLevel": 0
  },
  "curriculum_context": {
    "node_id": "C200",
    "depth_target": "D2"
  },
  "misconception_context": {
    "top_tags": []
  },
  "attempt_context": null,
  "evidence_context": null,
  "policy_context": {
    "allow_reveal": false
  },
  "memory_context": {},
  "scaffold_context": {
    "scaffold_id": "C200-pointer-depth2",
    "exercise_description": "Design a D2-level C pointers lab on arithmetic, decay semantics, restrict, and const-correctness, anchored in POSIX buffer handling scenarios with ambitious starter code and thorough behavioral tests.",
    "lesson_plan": {
      "section_intents": [
        "Motivate pointer arithmetic via high-throughput POSIX read buffers in network daemons needing zero-copy slices.",
        "Clarify byte-addressed memory layout, object lifetimes, and how POSIX APIs like read()/write() expect pointers and lengths.",
        "Detail rules for pointer arithmetic, difference types, and when results stay within the same allocated object per C17 6.5.6.",
        "Explain array-to-pointer decay at call boundaries, especially for POSIX functions expecting void* and size arguments.",
        "Worked example: walk an int buffer returned by read() using pointer increments, computing ptrdiff_t distances safely.",
        "Introduce restrict-qualified parameters for memcpy-style helpers and how they mirror POSIX memcpy/memmove guarantees.",
        "Contrast const pointer vs pointer-to-const: demonstrate composing const-correct wrappers over read-only shared memory.",
        "Worked example: construct readv()-style scatter/gather descriptors while preserving const and restrict promises.",
        "Pitfalls roundup: UB from overrunning arrays, comparing unrelated pointers, dangling decay results, signal-unsafely sharing restrict-qualified state.",
        "Compare pointer arithmetic on typed pointers vs void*; highlight when casts are needed and how const/restrict survive conversions.",
        "Bridge forward: preview how these pointer guarantees enable safer buffer pools and ownership models in upcoming memory-management lessons."
      ]
    },
    "starter_plan": {
      "file_intents": [
        "include/pointer_ops.h with four stubs: pointer_offset_diff, safe_ptr_add, array_decay_to_const, wraparound_guard.",
        "src/restrict_buffers.c with four stubs: restrict_sum, restrict_scale, restrict_memcpy, restrict_alias_window.",
        "src/const_contracts.c with three stubs: expose_readonly_view, set_config_buffer, mutable_from_void."
      ]
    },
    "test_plan": {
      "case_intents": [
        "pointer_offset_diff returns exact element distance for sorted sensor data pulled via read(); UB risk if unchecked subtraction is left empty—flag it.",
        "safe_ptr_add rejects offsets that escape the original allocation before returning a usable pointer; empty stub would let callers dereference UB—flag it.",
        "array_decay_to_const preserves element identity by returning the decayed pointer and confirms the source array height ≥4.",
        "wraparound_guard reports negative distances for candidates before base and positive for in-range ones; empty stub would silently allow UB.",
        "restrict_sum accumulates two restrict-qualified float arrays without aliasing, matching manual loop totals.",
        "restrict_scale multiplies src elements into dst without self-aliasing and ensures dst stays untouched when n==0.",
        "restrict_memcpy copies bytes without overlap (else returns error) to mirror memcpy vs memmove preconditions.",
        "restrict_alias_window reports true only when the byte ranges are disjoint, reinforcing restrict contracts.",
        "expose_readonly_view returns a stable const char* slice without letting callers mutate underlying storage.",
        "set_config_buffer writes value with const-correctness, truncating safely and always adding '\\0'.",
        "mutable_from_void lawfully casts back to a modifiable pointer only when original payload was non-const; must return NULL otherwise."
      ]
    }
  },
  "prior_loop_sections": [
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "restrict_buffers.c",
      "type": "code",
      "file_path": "restrict_buffers.c",
      "content": "#include <stddef.h>\n#include <stdbool.h>\n\n/* Use restrict-qualified inputs to accumulate disjoint float buffers in one pass, returning the total so callers can validate throughput math. */\nfloat restrict_sum(const float *restrict lhs,\n                   const float *restrict rhs,\n                   size_t count)\n{\n    (void)lhs;\n    (void)rhs;\n    (void)count;\n\n    return 0;\n}\n\n/* Scale a source buffer into a non-aliasing destination, honoring restrict promises while keeping n==0 as a no-op for callers benchmarking loops. */\nvoid restrict_scale(float *restrict dst,\n                    const float *restrict src,\n                    float multiplier,\n                    size_t count)\n{\n    (void)dst;\n    (void)src;\n    (void)multiplier;\n    (void)count;\n}\n\n/* Mirror memcpy semantics by first proving the byte ranges are disjoint; return 0 on success or a negative error when overlap would violate restrict guarantees. */\nint restrict_memcpy(void *restrict dst,\n                    const void *restrict src,\n                    size_t byte_len)\n{\n    (void)dst;\n    (void)src;\n    (void)byte_len;\n\n    return 0;\n}\n\n/* Report whether two candidate restrict windows are truly disjoint so higher-level buffer schedulers can uphold alias contracts before issuing reads. */\nbool restrict_alias_window(const void *restrict first,\n                           size_t first_len,\n                           const void *restrict second,\n                           size_t second_len)\n{\n    (void)first;\n    (void)first_len;\n    (void)second;\n    (void)second_len;\n\n    return 0;\n}\n",
      "is_complete": false,
      "next_focus": "const_contracts.c needs const-qualified pointer wrappers next."
    },
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "const_contracts.c",
      "type": "code",
      "file_path": "const_contracts.c",
      "content": "#include <stddef.h>\n#include <stdbool.h>\n\n/* Provide a const-correct slice over immutable storage so callers can peek at read()-produced buffers without mutating them; implement by bounds-checking the offset/length and recording the exposed length via view_len. */\nconst char *expose_readonly_view(const char *buffer,\n                                 size_t buffer_len,\n                                 size_t offset,\n                                 size_t min_view,\n                                 size_t *view_len)\n{\n    (void)buffer;\n    (void)buffer_len;\n    (void)offset;\n    (void)min_view;\n    (void)view_len;\n\n    return NULL;\n}\n\n/* Copy an ASCII configuration token into a mutable buffer while honoring const inputs, truncating safely, and always terminating with '\\'0'. */\nsize_t set_config_buffer(char *restrict dst,\n                         size_t dst_len,\n                         const char *restrict value)\n{\n    (void)dst;\n    (void)dst_len;\n    (void)value;\n\n    return 0;\n}\n\n/* Convert an erased pointer from POSIX APIs back to a mutable view only when the original allocation was non-const; otherwise return NULL to preserve const-correctness guarantees. */\nvoid *mutable_from_void(void *payload,\n                        bool original_was_const)\n{\n    (void)payload;\n    (void)original_was_const;\n\n    return NULL;\n}\n",
      "is_complete": false,
      "next_focus": "pointer_ops.h prototypes for pointer arithmetic helpers still need stubs."
    },
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "pointer_ops.h",
      "type": "code",
      "file_path": "pointer_ops.h",
      "content": "#ifndef POINTER_OPS_H\n#define POINTER_OPS_H\n\n#include <stddef.h>\n\n/* Compute the ptrdiff_t distance between two int pointers read from the same buffer so learners must verify cursor stays within element_count slots before subtracting. */\nstatic inline ptrdiff_t pointer_offset_diff(const int *base,\n                                            size_t element_count,\n                                            const int *cursor)\n{\n    (void)base;\n    (void)element_count;\n    (void)cursor;\n\n    return 0;\n}\n\n/* Add a signed byte offset to a POSIX read buffer without escaping its byte_len boundary, returning NULL when callers would wrap past the allocation. */\nstatic inline unsigned char *safe_ptr_add(unsigned char *base,\n                                          size_t byte_len,\n                                          ptrdiff_t byte_offset)\n{\n    (void)base;\n    (void)byte_len;\n    (void)byte_offset;\n\n    return NULL;\n}\n\n/* Demonstrate array-to-pointer decay by exposing a const view of a row while asserting the source has at least four rows before handing back the pointer. */\nstatic inline const unsigned char *array_decay_to_const(const unsigned char (*grid)[4],\n                                                        size_t rows,\n                                                        size_t row_index)\n{\n    (void)grid;\n    (void)rows;\n    (void)row_index;\n\n    return NULL;\n}\n\n/* Guard against pointer wraparound by reporting a signed distance: negative when candidate precedes base and positive only when it sits within span bytes. */\nstatic inline ptrdiff_t wraparound_guard(const unsigned char *base,\n                                         size_t span,\n                                         const unsigned char *candidate)\n{\n    (void)base;\n    (void)span;\n    (void)candidate;\n\n    return 0;\n}\n\n#endif /* POINTER_OPS_H */\n",
      "is_complete": true,
      "next_focus": "Starter scaffolding complete; learners can begin implementing pointer helpers."
    },
    {
      "schema_version": "test_section_v1",
      "role": "test-expand",
      "section_id": "pointer_const_restrict_tests",
      "type": "code",
      "file_path": "pointer_memory_tests.c",
      "content": "#include \"test.h\"\n#include \"pointer_ops.h\"\n#include \"restrict_buffers.h\"\n#include \"const_contracts.h\"\n#include <stddef.h>\n#include <string.h>\n#include <math.h>\n#include <stdbool.h>\n\nvoid test_pointer_offset_diff_in_range(void)\n{\n    int samples[] = {2, 4, 6, 8, 10, 12};\n    ptrdiff_t diff = pointer_offset_diff(samples, 6, &samples[4]);\n    TEST_ASSERT_EQ(4, diff);\n}\n\nvoid test_pointer_offset_diff_rejects_out_of_bounds(void)\n{\n    int samples[] = {5, 9, 14, 20, 25};\n    ptrdiff_t diff = pointer_offset_diff(samples, 5, samples + 5);\n    TEST_ASSERT(diff < 0);\n}\n\nvoid test_safe_ptr_add_within_bounds(void)\n{\n    unsigned char buffer[32] = {0};\n    unsigned char *cursor = safe_ptr_add(buffer, sizeof(buffer), 12);\n    TEST_ASSERT(cursor == buffer + 12);\n}\n\nvoid test_safe_ptr_add_rejects_escape(void)\n{\n    unsigned char buffer[16] = {0};\n    TEST_ASSERT(safe_ptr_add(buffer, sizeof(buffer), 20) == NULL);\n    TEST_ASSERT(safe_ptr_add(buffer, sizeof(buffer), -3) == NULL);\n}\n\nvoid test_array_decay_to_const_returns_row(void)\n{\n    unsigned char grid[4][4] = {\n        {0x10, 0x11, 0x12, 0x13},\n        {0x20, 0x21, 0x22, 0x23},\n        {0x30, 0x31, 0x32, 0x33},\n        {0x40, 0x41, 0x42, 0x43}\n    };\n    const unsigned char *row = array_decay_to_const(grid, 4, 2);\n    TEST_ASSERT(row != NULL);\n    TEST_ASSERT_EQ(0x30, row[0]);\n    TEST_ASSERT_EQ(0x33, row[3]);\n}\n\nvoid test_array_decay_to_const_requires_min_rows(void)\n{\n    unsigned char short_grid[3][4] = {{0}};\n    TEST_ASSERT(array_decay_to_const(short_grid, 3, 0) == NULL);\n\n    unsigned char tall_grid[4][4] = {{0}};\n    TEST_ASSERT(array_decay_to_const(tall_grid, 4, 4) == NULL);\n}\n\nvoid test_wraparound_guard_reports_positive_in_range(void)\n{\n    unsigned char buffer[64];\n    ptrdiff_t delta = wraparound_guard(buffer, sizeof(buffer), buffer + 28);\n    TEST_ASSERT_EQ(28, delta);\n    TEST_ASSERT_EQ(0, wraparound_guard(buffer, sizeof(buffer), buffer));\n}\n\nvoid test_wraparound_guard_flags_before_or_beyond(void)\n{\n    unsigned char buffer[64];\n    unsigned char *base = buffer + 10;\n    ptrdiff_t before = wraparound_guard(base, 10, buffer + 6);\n    TEST_ASSERT(before < 0);\n\n    ptrdiff_t beyond = wraparound_guard(buffer, 16, buffer + 32);\n    TEST_ASSERT(beyond < 0);\n}\n\nvoid test_restrict_sum_matches_manual(void)\n{\n    float lhs[] = {1.0f, 2.5f, -3.0f, 4.5f};\n    float rhs[] = {0.5f, 1.0f, 3.0f, -1.5f};\n    float total = restrict_sum(lhs, rhs, 4);\n    float manual = 0.0f;\n    for (size_t i = 0; i < 4; ++i) {\n        manual += lhs[i] + rhs[i];\n    }\n    TEST_ASSERT(fabsf(total - manual) < 1e-5f);\n}\n\nvoid test_restrict_scale_multiplies_without_alias(void)\n{\n    float src[] = {1.0f, -2.0f, 0.5f, 8.0f};\n    float dst[] = {10.0f, 10.0f, 10.0f, 10.0f};\n    restrict_scale(dst, src, 3.0f, 4);\n    for (size_t i = 0; i < 4; ++i) {\n        TEST_ASSERT(fabsf(dst[i] - (src[i] * 3.0f)) < 1e-5f);\n    }\n}\n\nvoid test_restrict_scale_noop_zero_count(void)\n{\n    float src[] = {5.0f};\n    float dst[] = {42.0f};\n    restrict_scale(dst, src, 7.0f, 0);\n    TEST_ASSERT(fabsf(dst[0] - 42.0f) < 1e-5f);\n}\n\nvoid test_restrict_memcpy_success(void)\n{\n    char src[] = \"socket-buffer\";\n    char dst[32];\n    memset(dst, 0, sizeof(dst));\n    int rc = restrict_memcpy(dst, src, strlen(src) + 1);\n    TEST_ASSERT_EQ(0, rc);\n    TEST_ASSERT_EQ(0, strcmp(dst, src));\n}\n\nvoid test_restrict_memcpy_detects_overlap(void)\n{\n    char buffer[32] = \"ABCDEFGHIJKL\";\n    char snapshot[32];\n    memcpy(snapshot, buffer, sizeof(buffer));\n    int rc = restrict_memcpy(buffer + 2, buffer, 8);\n    TEST_ASSERT(rc < 0);\n    TEST_ASSERT_EQ(0, memcmp(buffer, snapshot, sizeof(buffer)));\n}\n\nvoid test_restrict_alias_window_disjoint(void)\n{\n    unsigned char first[8] = {0};\n    unsigned char second[8] = {0};\n    TEST_ASSERT(restrict_alias_window(first, sizeof(first), second, sizeof(second)));\n}\n\nvoid test_restrict_alias_window_overlap(void)\n{\n    unsigned char buffer[32];\n    bool ok = restrict_alias_window(buffer, 12, buffer + 6, 10);\n    TEST_ASSERT(!ok);\n}\n\nvoid test_expose_readonly_view_sets_length(void)\n{\n    const char payload[] = \"read-buffer:alpha\";\n    size_t view_len = 0;\n    const char *view = expose_readonly_view(payload, sizeof(payload) - 1, 5, 6, &view_len);\n    TEST_ASSERT(view == payload + 5);\n    TEST_ASSERT_EQ((sizeof(payload) - 1) - 5, view_len);\n    TEST_ASSERT_EQ('b', view[1]);\n}\n\nvoid test_expose_readonly_view_rejects_short_window(void)\n{\n    const char payload[] = \"abc\";\n    size_t view_len = 99;\n    const char *view = expose_readonly_view(payload, sizeof(payload) - 1, 1, 4, &view_len);\n    TEST_ASSERT(view == NULL);\n    TEST_ASSERT_EQ(0, view_len);\n}\n\nvoid test_set_config_buffer_exact_copy(void)\n{\n    char dst[32];\n    memset(dst, 0xAA, sizeof(dst));\n    const char *value = \"MODE=fast\";\n    size_t copied = set_config_buffer(dst, sizeof(dst), value);\n    TEST_ASSERT_EQ(strlen(value), copied);\n    TEST_ASSERT_EQ(0, strcmp(value, dst));\n}\n\nvoid test_set_config_buffer_truncates_and_terminates(void)\n{\n    char dst[5];\n    memset(dst, 0xAA, sizeof(dst));\n    size_t copied = set_config_buffer(dst, sizeof(dst), \"LONGVALUE\");\n    TEST_ASSERT_EQ(sizeof(dst) - 1, copied);\n    TEST_ASSERT_EQ('\\0', dst[sizeof(dst) - 1]);\n    TEST_ASSERT_EQ(0, strncmp(\"LONGVALUE\", dst, sizeof(dst) - 1));\n}\n\nvoid test_mutable_from_void_allows_mutable_payload(void)\n{\n    int value = 17;\n    int *restored = (int *)mutable_from_void(&value, false);\n    TEST_ASSERT(restored != NULL);\n    *restored = 99;\n    TEST_ASSERT_EQ(99, value);\n}\n\nvoid test_mutable_from_void_rejects_const_payload(void)\n{\n    int value = 33;\n    void *restored = mutable_from_void(&value, true);\n    TEST_ASSERT(restored == NULL);\n    TEST_ASSERT_EQ(33, value);\n}\n\nint main(void)\n{\n    RUN_TEST(test_pointer_offset_diff_in_range);\n    RUN_TEST(test_pointer_offset_diff_rejects_out_of_bounds);\n    RUN_TEST(test_safe_ptr_add_within_bounds);\n    RUN_TEST(test_safe_ptr_add_rejects_escape);\n    RUN_TEST(test_array_decay_to_const_returns_row);\n    RUN_TEST(test_array_decay_to_const_requires_min_rows);\n    RUN_TEST(test_wraparound_guard_reports_positive_in_range);\n    RUN_TEST(test_wraparound_guard_flags_before_or_beyond);\n    RUN_TEST(test_restrict_sum_matches_manual);\n    RUN_TEST(test_restrict_scale_multiplies_without_alias);\n    RUN_TEST(test_restrict_scale_noop_zero_count);\n    RUN_TEST(test_restrict_memcpy_success);\n    RUN_TEST(test_restrict_memcpy_detects_overlap);\n    RUN_TEST(test_restrict_alias_window_disjoint);\n    RUN_TEST(test_restrict_alias_window_overlap);\n    RUN_TEST(test_expose_readonly_view_sets_length);\n    RUN_TEST(test_expose_readonly_view_rejects_short_window);\n    RUN_TEST(test_set_config_buffer_exact_copy);\n    RUN_TEST(test_set_config_buffer_truncates_and_terminates);\n    RUN_TEST(test_mutable_from_void_allows_mutable_payload);\n    RUN_TEST(test_mutable_from_void_rejects_const_payload);\n    TEST_SUMMARY();\n}\n",
      "is_complete": true,
      "next_focus": ""
    }
  ],
  "current_sections": [
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "sec-pointer-motivation",
      "type": "concept",
      "content": "High-throughput network daemons live or die by how efficiently they churn through POSIX `read()` buffers. Every extra copy between kernel-provided bytes and user-level parsers increases cache pressure and latency, so systems engineers lean on pointer arithmetic to carve zero-copy slices of the exact payload regions they need. Picture an edge proxy that batches TLS records arriving over a non-blocking socket. It pulls as many bytes as possible into a pre-allocated window, then advances lightweight cursors that mark frame boundaries without ever reallocating. That approach only works if you can reason precisely about how far each cursor sits from the base of the buffer and whether a micro-slice stays inside the data returned by the last syscall. ```c\n#include <unistd.h>\n#include <stddef.h>\n#include <stdint.h>\n\nssize_t fill_window(int fd, uint8_t *buf, size_t cap)\n{\n    ssize_t bytes = read(fd, buf, cap);\n    if (bytes <= 0) {\n        return bytes; /* errno already set */\n    }\n\n    uint8_t *cursor = buf;\n    uint8_t *limit = buf + bytes;\n    while (cursor + 64 <= limit) {\n        process_frame(cursor, 64); /* zero-copy slice */\n        cursor += 64;              /* pointer arithmetic drives batching */\n    }\n    stash_partial(cursor, (size_t)(limit - cursor));\n    return bytes;\n}\n```Every pointer increment, subtraction, and comparison inside this loop replaces what would otherwise be expensive `memcpy()` calls. Getting comfortable with those operations is the gateway to designing DMA-friendly pipelines, scatter/gather I/O, and buffer pools that keep up with modern NICs.",
      "is_complete": false,
      "next_focus": "Clarify byte-addressed memory layout, object lifetimes, and how POSIX APIs like read()/write() expect pointers and lengths."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "sec-byte-layout",
      "type": "concept",
      "content": "C’s pointer model is anchored in byte-addressed memory, so every object you hand to POSIX I/O has an addressable first byte, a size in bytes, and a lifetime that must still be active when the kernel touches it. When you call `ssize_t read(int fd, void *buf, size_t count)`, the kernel assumes `buf` points to at least `count` contiguous bytes of live storage. If the buffer was allocated on the stack and the function returns before the data is consumed, dereferencing that pointer later means you are reading from reclaimed stack slots—pure undefined behavior. The same thinking applies to `write()`: the kernel copies from user space only while the call is in flight, so the bytes must remain stable for the duration of the syscall. ```c\n#include <unistd.h>\n#include <stdint.h>\n#include <sys/uio.h>\n\nssize_t read_frame(int fd, uint8_t *storage, size_t cap)\n{\n    if (cap < 1500) {\n        return -1; /* reject undersized lifetime */\n    }\n\n    ssize_t n = read(fd, storage, cap);\n    if (n <= 0) {\n        return n;\n    }\n\n    /* safe: storage still lives, and every byte up to n-1 was written */\n    return write(STDOUT_FILENO, storage, (size_t)n);\n}\n```Notice how both `read()` and `write()` receive explicit byte counts; neither API infers length from the pointer itself. Keeping track of which object a pointer came from, how many bytes were promised, and whether that storage still exists is the bedrock for the arithmetic-heavy techniques we’ll need later.",
      "is_complete": false,
      "next_focus": "Detail rules for pointer arithmetic, difference types, and when results stay within the same allocated object per C17 6.5.6."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "sec-pointer-arithmetic",
      "type": "concept",
      "content": "C17 6.5.6 only blesses pointer arithmetic when the operands refer to elements of the same array object (or the sentinel one-past-the-end). Adding an integer `n` to `T *p` conceptually walks `n` slots of size `sizeof(T)`; if the walk escapes the allocation the behavior is undefined even before you dereference. Subtracting two compatible pointers yields a `ptrdiff_t`, a signed difference type large enough to describe how many elements separate them. That result is only meaningful when both pointers originated from the same live array, making `ptrdiff_t` the canonical way to talk about cursor gaps inside POSIX buffers. Pointer comparisons follow the same rule: only perform relational operators on pointers into the same object. Attempting to compare or subtract unrelated pointers, or straying more than one slot past the allocation, forfeits all guarantees. ```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t frame_bytes_remaining(uint8_t *base, size_t filled)\n{\n    uint8_t *cursor = base;\n    uint8_t *limit = base + filled; /* valid one-past */\n    while ((cursor + 64) <= limit) {\n        process_frame(cursor, 64);\n        cursor += 64; /* stays within the buffer */\n    }\n    ptrdiff_t diff = limit - cursor; /* defined: both in same object */\n    return (diff >= 0) ? (size_t)diff : 0u;\n}\n```This snippet keeps every pointer addition inside the `base[0..filled]` allocation, then casts the `ptrdiff_t` difference to an unsigned size only after confirming it is non-negative. That is the disciplined pattern you need whenever you advance cursors through kernel-filled storage: add offsets cautiously, subtract only matching pointers, and treat `ptrdiff_t` as the authoritative measure of safe distance.",
      "is_complete": false,
      "next_focus": "Explain array-to-pointer decay at call boundaries, especially for POSIX functions expecting void* and size arguments."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "sec-array-decay",
      "type": "concept",
      "content": "At every POSIX boundary, arrays silently decay to pointers, so the callee sees only the address of element zero and must rely on an explicit size argument to bound access. When you pass `uint8_t window[2048]` to `read()`, it becomes `uint8_t *` automatically, preserving element type so pointer arithmetic still advances a byte at a time. Decay does not carry the array’s length, nor does it extend the object’s lifetime—those responsibilities stay with the caller. This is why buffer APIs nearly always take `void *buf, size_t len`: the pointer may come from any array type, but the byte count enforces how much storage is actually valid. If you need to expose only a sub-row of a multi-dimensional array, decay again yields the first element of that row, so you must ensure the subarray remains in scope. ```c\n#include <unistd.h>\n#include <stdint.h>\n#include <stddef.h>\n\nssize_t recv_payload(int fd, uint8_t (*grid)[512], size_t rows)\n{\n    if (rows == 0) {\n        return -1;\n    }\n\n    uint8_t *row0 = grid[0];           /* array-to-pointer decay */\n    ssize_t n = read(fd, row0, sizeof(grid[0]));\n    if (n <= 0) {\n        return n;\n    }\n\n    const void *row1_view = grid[1];    /* void* accepts any element type */\n    return write(STDOUT_FILENO, row1_view, (size_t)n);\n}\n```Whenever you cast to `void *`, the element size information disappears entirely, so treat all offsets as raw bytes and reintroduce the correct element type before performing typed arithmetic.",
      "is_complete": false,
      "next_focus": "Worked example: walk an int buffer returned by read() using pointer increments, computing ptrdiff_t distances safely."
    },
    {
      "schema_version": "lesson_section_v1",
      "role": "lesson-expand",
      "section_id": "sec-int-buffer-walk",
      "type": "worked_example",
      "content": "We now turn the rules into practice by walking an `int` buffer filled via `read()` and computing distances between cursors using `ptrdiff_t`. The example below performs one blocking read from a sensor pipe, scans the resulting integers until their cumulative sum breaches a threshold, and reports how many elements were consumed. Every pointer arithmetic step stays inside the allocation, and subtracting pointers only happens when they originate from that same block.\n```c\n#include <unistd.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <errno.h>\n\n#define SAMPLE_CAP 256\n#define TRIPWIRE   1000\n\nint main(void)\n{\n    static int samples[SAMPLE_CAP];\n    ssize_t bytes = read(STDIN_FILENO, samples, sizeof(samples));\n    if (bytes < 0) {\n        perror(\"read\");\n        return 1;\n    }\n    size_t filled = (size_t)bytes / sizeof(samples[0]);\n\n    int *cursor = samples;\n    int *limit  = samples + filled; /* one-past-the-last written element */\n    int *trip   = cursor;\n    long total  = 0;\n\n    while (cursor < limit && total < TRIPWIRE) {\n        total += *cursor;\n        cursor += 1; /* advances one int at a time */\n    }\n\n    ptrdiff_t consumed = cursor - trip; /* well-defined difference */\n    printf(\"sum=%ld across %td ints\\n\", total, consumed);\n\n    if (cursor < limit) {\n        ptrdiff_t remaining = limit - cursor;\n        printf(\"%td ints remain for later processing\\n\", remaining);\n    }\n    return 0;\n}\n```\nKey takeaways: (1) convert the byte count returned by `read()` into an element count before stepping through the buffer, (2) keep a stable `trip` pointer anchored to the same object so the subtraction `cursor - trip` yields an accurate `ptrdiff_t`, and (3) treat the `limit` pointer as the sole guard for every increment, ensuring no cursor walks past the region the kernel actually populated.",
      "is_complete": false,
      "next_focus": "Introduce restrict-qualified parameters for memcpy-style helpers and how they mirror POSIX memcpy/memmove guarantees."
    }
  ],
  "next_focus": "Introduce restrict-qualified parameters for memcpy-style helpers and how they mirror POSIX memcpy/memmove guarantees."
}