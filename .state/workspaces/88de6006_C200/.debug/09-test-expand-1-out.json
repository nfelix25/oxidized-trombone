{
  "accepted": true,
  "schemaName": "test_section_v1",
  "payload": {
    "schema_version": "test_section_v1",
    "role": "test-expand",
    "section_id": "pointer_const_restrict_tests",
    "type": "code",
    "file_path": "pointer_memory_tests.c",
    "content": "#include \"test.h\"\n#include \"pointer_ops.h\"\n#include \"restrict_buffers.h\"\n#include \"const_contracts.h\"\n#include <stddef.h>\n#include <string.h>\n#include <math.h>\n#include <stdbool.h>\n\nvoid test_pointer_offset_diff_in_range(void)\n{\n    int samples[] = {2, 4, 6, 8, 10, 12};\n    ptrdiff_t diff = pointer_offset_diff(samples, 6, &samples[4]);\n    TEST_ASSERT_EQ(4, diff);\n}\n\nvoid test_pointer_offset_diff_rejects_out_of_bounds(void)\n{\n    int samples[] = {5, 9, 14, 20, 25};\n    ptrdiff_t diff = pointer_offset_diff(samples, 5, samples + 5);\n    TEST_ASSERT(diff < 0);\n}\n\nvoid test_safe_ptr_add_within_bounds(void)\n{\n    unsigned char buffer[32] = {0};\n    unsigned char *cursor = safe_ptr_add(buffer, sizeof(buffer), 12);\n    TEST_ASSERT(cursor == buffer + 12);\n}\n\nvoid test_safe_ptr_add_rejects_escape(void)\n{\n    unsigned char buffer[16] = {0};\n    TEST_ASSERT(safe_ptr_add(buffer, sizeof(buffer), 20) == NULL);\n    TEST_ASSERT(safe_ptr_add(buffer, sizeof(buffer), -3) == NULL);\n}\n\nvoid test_array_decay_to_const_returns_row(void)\n{\n    unsigned char grid[4][4] = {\n        {0x10, 0x11, 0x12, 0x13},\n        {0x20, 0x21, 0x22, 0x23},\n        {0x30, 0x31, 0x32, 0x33},\n        {0x40, 0x41, 0x42, 0x43}\n    };\n    const unsigned char *row = array_decay_to_const(grid, 4, 2);\n    TEST_ASSERT(row != NULL);\n    TEST_ASSERT_EQ(0x30, row[0]);\n    TEST_ASSERT_EQ(0x33, row[3]);\n}\n\nvoid test_array_decay_to_const_requires_min_rows(void)\n{\n    unsigned char short_grid[3][4] = {{0}};\n    TEST_ASSERT(array_decay_to_const(short_grid, 3, 0) == NULL);\n\n    unsigned char tall_grid[4][4] = {{0}};\n    TEST_ASSERT(array_decay_to_const(tall_grid, 4, 4) == NULL);\n}\n\nvoid test_wraparound_guard_reports_positive_in_range(void)\n{\n    unsigned char buffer[64];\n    ptrdiff_t delta = wraparound_guard(buffer, sizeof(buffer), buffer + 28);\n    TEST_ASSERT_EQ(28, delta);\n    TEST_ASSERT_EQ(0, wraparound_guard(buffer, sizeof(buffer), buffer));\n}\n\nvoid test_wraparound_guard_flags_before_or_beyond(void)\n{\n    unsigned char buffer[64];\n    unsigned char *base = buffer + 10;\n    ptrdiff_t before = wraparound_guard(base, 10, buffer + 6);\n    TEST_ASSERT(before < 0);\n\n    ptrdiff_t beyond = wraparound_guard(buffer, 16, buffer + 32);\n    TEST_ASSERT(beyond < 0);\n}\n\nvoid test_restrict_sum_matches_manual(void)\n{\n    float lhs[] = {1.0f, 2.5f, -3.0f, 4.5f};\n    float rhs[] = {0.5f, 1.0f, 3.0f, -1.5f};\n    float total = restrict_sum(lhs, rhs, 4);\n    float manual = 0.0f;\n    for (size_t i = 0; i < 4; ++i) {\n        manual += lhs[i] + rhs[i];\n    }\n    TEST_ASSERT(fabsf(total - manual) < 1e-5f);\n}\n\nvoid test_restrict_scale_multiplies_without_alias(void)\n{\n    float src[] = {1.0f, -2.0f, 0.5f, 8.0f};\n    float dst[] = {10.0f, 10.0f, 10.0f, 10.0f};\n    restrict_scale(dst, src, 3.0f, 4);\n    for (size_t i = 0; i < 4; ++i) {\n        TEST_ASSERT(fabsf(dst[i] - (src[i] * 3.0f)) < 1e-5f);\n    }\n}\n\nvoid test_restrict_scale_noop_zero_count(void)\n{\n    float src[] = {5.0f};\n    float dst[] = {42.0f};\n    restrict_scale(dst, src, 7.0f, 0);\n    TEST_ASSERT(fabsf(dst[0] - 42.0f) < 1e-5f);\n}\n\nvoid test_restrict_memcpy_success(void)\n{\n    char src[] = \"socket-buffer\";\n    char dst[32];\n    memset(dst, 0, sizeof(dst));\n    int rc = restrict_memcpy(dst, src, strlen(src) + 1);\n    TEST_ASSERT_EQ(0, rc);\n    TEST_ASSERT_EQ(0, strcmp(dst, src));\n}\n\nvoid test_restrict_memcpy_detects_overlap(void)\n{\n    char buffer[32] = \"ABCDEFGHIJKL\";\n    char snapshot[32];\n    memcpy(snapshot, buffer, sizeof(buffer));\n    int rc = restrict_memcpy(buffer + 2, buffer, 8);\n    TEST_ASSERT(rc < 0);\n    TEST_ASSERT_EQ(0, memcmp(buffer, snapshot, sizeof(buffer)));\n}\n\nvoid test_restrict_alias_window_disjoint(void)\n{\n    unsigned char first[8] = {0};\n    unsigned char second[8] = {0};\n    TEST_ASSERT(restrict_alias_window(first, sizeof(first), second, sizeof(second)));\n}\n\nvoid test_restrict_alias_window_overlap(void)\n{\n    unsigned char buffer[32];\n    bool ok = restrict_alias_window(buffer, 12, buffer + 6, 10);\n    TEST_ASSERT(!ok);\n}\n\nvoid test_expose_readonly_view_sets_length(void)\n{\n    const char payload[] = \"read-buffer:alpha\";\n    size_t view_len = 0;\n    const char *view = expose_readonly_view(payload, sizeof(payload) - 1, 5, 6, &view_len);\n    TEST_ASSERT(view == payload + 5);\n    TEST_ASSERT_EQ((sizeof(payload) - 1) - 5, view_len);\n    TEST_ASSERT_EQ('b', view[1]);\n}\n\nvoid test_expose_readonly_view_rejects_short_window(void)\n{\n    const char payload[] = \"abc\";\n    size_t view_len = 99;\n    const char *view = expose_readonly_view(payload, sizeof(payload) - 1, 1, 4, &view_len);\n    TEST_ASSERT(view == NULL);\n    TEST_ASSERT_EQ(0, view_len);\n}\n\nvoid test_set_config_buffer_exact_copy(void)\n{\n    char dst[32];\n    memset(dst, 0xAA, sizeof(dst));\n    const char *value = \"MODE=fast\";\n    size_t copied = set_config_buffer(dst, sizeof(dst), value);\n    TEST_ASSERT_EQ(strlen(value), copied);\n    TEST_ASSERT_EQ(0, strcmp(value, dst));\n}\n\nvoid test_set_config_buffer_truncates_and_terminates(void)\n{\n    char dst[5];\n    memset(dst, 0xAA, sizeof(dst));\n    size_t copied = set_config_buffer(dst, sizeof(dst), \"LONGVALUE\");\n    TEST_ASSERT_EQ(sizeof(dst) - 1, copied);\n    TEST_ASSERT_EQ('\\0', dst[sizeof(dst) - 1]);\n    TEST_ASSERT_EQ(0, strncmp(\"LONGVALUE\", dst, sizeof(dst) - 1));\n}\n\nvoid test_mutable_from_void_allows_mutable_payload(void)\n{\n    int value = 17;\n    int *restored = (int *)mutable_from_void(&value, false);\n    TEST_ASSERT(restored != NULL);\n    *restored = 99;\n    TEST_ASSERT_EQ(99, value);\n}\n\nvoid test_mutable_from_void_rejects_const_payload(void)\n{\n    int value = 33;\n    void *restored = mutable_from_void(&value, true);\n    TEST_ASSERT(restored == NULL);\n    TEST_ASSERT_EQ(33, value);\n}\n\nint main(void)\n{\n    RUN_TEST(test_pointer_offset_diff_in_range);\n    RUN_TEST(test_pointer_offset_diff_rejects_out_of_bounds);\n    RUN_TEST(test_safe_ptr_add_within_bounds);\n    RUN_TEST(test_safe_ptr_add_rejects_escape);\n    RUN_TEST(test_array_decay_to_const_returns_row);\n    RUN_TEST(test_array_decay_to_const_requires_min_rows);\n    RUN_TEST(test_wraparound_guard_reports_positive_in_range);\n    RUN_TEST(test_wraparound_guard_flags_before_or_beyond);\n    RUN_TEST(test_restrict_sum_matches_manual);\n    RUN_TEST(test_restrict_scale_multiplies_without_alias);\n    RUN_TEST(test_restrict_scale_noop_zero_count);\n    RUN_TEST(test_restrict_memcpy_success);\n    RUN_TEST(test_restrict_memcpy_detects_overlap);\n    RUN_TEST(test_restrict_alias_window_disjoint);\n    RUN_TEST(test_restrict_alias_window_overlap);\n    RUN_TEST(test_expose_readonly_view_sets_length);\n    RUN_TEST(test_expose_readonly_view_rejects_short_window);\n    RUN_TEST(test_set_config_buffer_exact_copy);\n    RUN_TEST(test_set_config_buffer_truncates_and_terminates);\n    RUN_TEST(test_mutable_from_void_allows_mutable_payload);\n    RUN_TEST(test_mutable_from_void_rejects_const_payload);\n    TEST_SUMMARY();\n}\n",
    "is_complete": true,
    "next_focus": ""
  }
}