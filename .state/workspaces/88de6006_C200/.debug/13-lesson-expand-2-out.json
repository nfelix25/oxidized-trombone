{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "sec-byte-layout",
    "type": "concept",
    "content": "C’s pointer model is anchored in byte-addressed memory, so every object you hand to POSIX I/O has an addressable first byte, a size in bytes, and a lifetime that must still be active when the kernel touches it. When you call `ssize_t read(int fd, void *buf, size_t count)`, the kernel assumes `buf` points to at least `count` contiguous bytes of live storage. If the buffer was allocated on the stack and the function returns before the data is consumed, dereferencing that pointer later means you are reading from reclaimed stack slots—pure undefined behavior. The same thinking applies to `write()`: the kernel copies from user space only while the call is in flight, so the bytes must remain stable for the duration of the syscall. ```c\n#include <unistd.h>\n#include <stdint.h>\n#include <sys/uio.h>\n\nssize_t read_frame(int fd, uint8_t *storage, size_t cap)\n{\n    if (cap < 1500) {\n        return -1; /* reject undersized lifetime */\n    }\n\n    ssize_t n = read(fd, storage, cap);\n    if (n <= 0) {\n        return n;\n    }\n\n    /* safe: storage still lives, and every byte up to n-1 was written */\n    return write(STDOUT_FILENO, storage, (size_t)n);\n}\n```Notice how both `read()` and `write()` receive explicit byte counts; neither API infers length from the pointer itself. Keeping track of which object a pointer came from, how many bytes were promised, and whether that storage still exists is the bedrock for the arithmetic-heavy techniques we’ll need later.",
    "is_complete": false,
    "next_focus": "Detail rules for pointer arithmetic, difference types, and when results stay within the same allocated object per C17 6.5.6."
  }
}