{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "sec-readv-scatter",
    "type": "worked_example",
    "content": "Scatter/gather reads let a daemon refill cache-friendly windows in one syscall while keeping metadata const so scheduling logic cannot accidentally retarget buffers mid-flight. Each descriptor records a `uint8_t *restrict` destination plus the length that `readv()` should honor, and the table of descriptors itself is passed as `const struct span *restrict` to guarantee the helper never alters layout. Before hitting the kernel we must prove the windows are disjoint so the `restrict` promises stay true; otherwise the compiler could vectorize overlapping stores and corrupt the stream.\n```c\n#include <sys/uio.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <errno.h>\n#include <stdio.h>\n\n#define MAX_SPANS 4\n\nstruct span {\n    uint8_t *restrict dst;\n    size_t len;\n};\n\nstatic int spans_disjoint(const struct span *restrict spans, size_t count)\n{\n    for (size_t i = 0; i < count; ++i) {\n        const uint8_t *start_i = spans[i].dst;\n        const uint8_t *end_i = start_i + spans[i].len;\n        for (size_t j = i + 1; j < count; ++j) {\n            const uint8_t *start_j = spans[j].dst;\n            const uint8_t *end_j = start_j + spans[j].len;\n            if (!(end_i <= start_j || end_j <= start_i)) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nssize_t read_scatter(int fd,\n                     const struct span *restrict spans,\n                     size_t count)\n{\n    if (!spans || count == 0 || count > MAX_SPANS) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (!spans_disjoint(spans, count)) {\n        errno = EOVERFLOW;\n        return -1;\n    }\n\n    struct iovec vecs[MAX_SPANS];\n    for (size_t i = 0; i < count; ++i) {\n        vecs[i].iov_base = spans[i].dst;\n        vecs[i].iov_len = spans[i].len;\n    }\n\n    ssize_t bytes = readv(fd, vecs, (int)count);\n    if (bytes < 0) {\n        perror(\"readv\");\n    }\n    return bytes;\n}\n```\nAfter the call we only inspect the returned byte count; the buffer contents remain mutable via their `restrict` cursors, while the descriptor array stays immutable, making it safe to reuse across event-loop iterations. This pattern mirrors `readv()`-powered TLS terminators that predeclare handshake, payload, and log regions yet refuse to relax aliasing rules, enabling aggressive compiler optimizations without sacrificing const correctness.",
    "is_complete": false,
    "next_focus": "Pitfalls roundup: UB from overrunning arrays, comparing unrelated pointers, dangling decay results, signal-unsafely sharing restrict-qualified state."
  }
}