{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "sec-pointer-pitfalls",
    "type": "pitfalls",
    "content": "Four classic traps wait inside POSIX buffer plumbing. Overrunning the array returned by `read()` triggers AddressSanitizer’s “stack-buffer-overflow” the instant `buf[32]` is touched, because the legal index range is `0..31`. Subtracting unrelated pointers provokes UBSan’s “pointer overflow” diagnostic even before dereference, since `&stack_byte - heap_pool` crosses objects. Returning a decayed pointer to a stack row makes Clang warn with `-Wreturn-stack-address`, and dereferencing it later is a time bomb. Finally, letting an async signal handler mutate a `restrict` cursor breaks the aliasing promise and ThreadSanitizer flags a data race, since the handler runs concurrently with the main loop that assumed exclusive writes. \n```c\n#include <unistd.h>\n#include <stddef.h>\n#include <signal.h>\n#include <stdint.h>\n\nssize_t grab(int fd, uint8_t buf[32]) {\n    ssize_t n = read(fd, buf, sizeof buf);\n    return buf[32]; /* UB: ASan stack-buffer-overflow */\n}\n\nptrdiff_t nonsensical_gap(void) {\n    uint8_t stack_byte;\n    extern uint8_t *heap_pool;\n    return &stack_byte - heap_pool; /* UBSan pointer overflow */\n}\n\nconst char *bad_decay(void) {\n    char row[16] = \"tmp\";\n    return row; /* clang -Wreturn-stack-address */\n}\n\nuint8_t *restrict log_cursor;\nvoid handler(int sig) { (void)sig; log_cursor += 64; } /* TSAN data race */\n```\n```c\nssize_t grab_safe(int fd, uint8_t buf[32]) {\n    ssize_t n = read(fd, buf, sizeof buf);\n    if (n <= 0 || (size_t)n > sizeof buf) { return n; }\n    return buf[(size_t)n - 1];\n}\n\nptrdiff_t gap_within(const uint8_t *base, size_t len, const uint8_t *cursor) {\n    const uint8_t *end = base + len;\n    return (cursor >= base && cursor <= end) ? (cursor - base) : -1;\n}\n\nconst char *stable_decay(const char (*grid)[16], size_t rows, size_t row) {\n    return (row < rows) ? grid[row] : NULL;\n}\n\nvolatile sig_atomic_t bump_requested;\nvoid handler(int sig) { (void)sig; bump_requested = 1; }\nvoid pump_log_cursor(uint8_t *restrict cursor, size_t stride) {\n    if (bump_requested) {\n        cursor += stride; /* single-threaded update preserves restrict */\n        bump_requested = 0;\n    }\n}\n```\nGuarding indices, subtracting only within the same object, returning storage that outlives the caller, and confining `restrict` state to signal-safe rendezvous keep these bugs—and their sanitizer screams—out of your labs.",
    "is_complete": false,
    "next_focus": "Compare pointer arithmetic on typed pointers vs void*; highlight when casts are needed and how const/restrict survive conversions."
  }
}