{
  "schema_version": "context_packet_v1",
  "packet_id": "ac436075-1964-4cb7-b534-999b41a42018",
  "timestamp_utc": "2026-02-24T20:11:01.325Z",
  "role": "starter-expand",
  "task_type": "starter_expand",
  "learner_profile": {
    "masteryLevel": 0
  },
  "curriculum_context": {
    "node_id": "C200",
    "depth_target": "D2"
  },
  "misconception_context": {
    "top_tags": []
  },
  "attempt_context": null,
  "evidence_context": null,
  "policy_context": {
    "allow_reveal": false
  },
  "memory_context": {},
  "scaffold_context": {
    "scaffold_id": "C200-pointer-depth2",
    "exercise_description": "Design a D2-level C pointers lab on arithmetic, decay semantics, restrict, and const-correctness, anchored in POSIX buffer handling scenarios with ambitious starter code and thorough behavioral tests.",
    "lesson_plan": {
      "section_intents": [
        "Motivate pointer arithmetic via high-throughput POSIX read buffers in network daemons needing zero-copy slices.",
        "Clarify byte-addressed memory layout, object lifetimes, and how POSIX APIs like read()/write() expect pointers and lengths.",
        "Detail rules for pointer arithmetic, difference types, and when results stay within the same allocated object per C17 6.5.6.",
        "Explain array-to-pointer decay at call boundaries, especially for POSIX functions expecting void* and size arguments.",
        "Worked example: walk an int buffer returned by read() using pointer increments, computing ptrdiff_t distances safely.",
        "Introduce restrict-qualified parameters for memcpy-style helpers and how they mirror POSIX memcpy/memmove guarantees.",
        "Contrast const pointer vs pointer-to-const: demonstrate composing const-correct wrappers over read-only shared memory.",
        "Worked example: construct readv()-style scatter/gather descriptors while preserving const and restrict promises.",
        "Pitfalls roundup: UB from overrunning arrays, comparing unrelated pointers, dangling decay results, signal-unsafely sharing restrict-qualified state.",
        "Compare pointer arithmetic on typed pointers vs void*; highlight when casts are needed and how const/restrict survive conversions.",
        "Bridge forward: preview how these pointer guarantees enable safer buffer pools and ownership models in upcoming memory-management lessons."
      ]
    },
    "starter_plan": {
      "file_intents": [
        "include/pointer_ops.h with four stubs: pointer_offset_diff, safe_ptr_add, array_decay_to_const, wraparound_guard.",
        "src/restrict_buffers.c with four stubs: restrict_sum, restrict_scale, restrict_memcpy, restrict_alias_window.",
        "src/const_contracts.c with three stubs: expose_readonly_view, set_config_buffer, mutable_from_void."
      ]
    },
    "test_plan": {
      "case_intents": [
        "pointer_offset_diff returns exact element distance for sorted sensor data pulled via read(); UB risk if unchecked subtraction is left empty—flag it.",
        "safe_ptr_add rejects offsets that escape the original allocation before returning a usable pointer; empty stub would let callers dereference UB—flag it.",
        "array_decay_to_const preserves element identity by returning the decayed pointer and confirms the source array height ≥4.",
        "wraparound_guard reports negative distances for candidates before base and positive for in-range ones; empty stub would silently allow UB.",
        "restrict_sum accumulates two restrict-qualified float arrays without aliasing, matching manual loop totals.",
        "restrict_scale multiplies src elements into dst without self-aliasing and ensures dst stays untouched when n==0.",
        "restrict_memcpy copies bytes without overlap (else returns error) to mirror memcpy vs memmove preconditions.",
        "restrict_alias_window reports true only when the byte ranges are disjoint, reinforcing restrict contracts.",
        "expose_readonly_view returns a stable const char* slice without letting callers mutate underlying storage.",
        "set_config_buffer writes value with const-correctness, truncating safely and always adding '\\0'.",
        "mutable_from_void lawfully casts back to a modifiable pointer only when original payload was non-const; must return NULL otherwise."
      ]
    }
  },
  "prior_loop_sections": [],
  "current_sections": [
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "restrict_buffers.c",
      "type": "code",
      "file_path": "restrict_buffers.c",
      "content": "#include <stddef.h>\n#include <stdbool.h>\n\n/* Use restrict-qualified inputs to accumulate disjoint float buffers in one pass, returning the total so callers can validate throughput math. */\nfloat restrict_sum(const float *restrict lhs,\n                   const float *restrict rhs,\n                   size_t count)\n{\n    (void)lhs;\n    (void)rhs;\n    (void)count;\n\n    return 0;\n}\n\n/* Scale a source buffer into a non-aliasing destination, honoring restrict promises while keeping n==0 as a no-op for callers benchmarking loops. */\nvoid restrict_scale(float *restrict dst,\n                    const float *restrict src,\n                    float multiplier,\n                    size_t count)\n{\n    (void)dst;\n    (void)src;\n    (void)multiplier;\n    (void)count;\n}\n\n/* Mirror memcpy semantics by first proving the byte ranges are disjoint; return 0 on success or a negative error when overlap would violate restrict guarantees. */\nint restrict_memcpy(void *restrict dst,\n                    const void *restrict src,\n                    size_t byte_len)\n{\n    (void)dst;\n    (void)src;\n    (void)byte_len;\n\n    return 0;\n}\n\n/* Report whether two candidate restrict windows are truly disjoint so higher-level buffer schedulers can uphold alias contracts before issuing reads. */\nbool restrict_alias_window(const void *restrict first,\n                           size_t first_len,\n                           const void *restrict second,\n                           size_t second_len)\n{\n    (void)first;\n    (void)first_len;\n    (void)second;\n    (void)second_len;\n\n    return 0;\n}\n",
      "is_complete": false,
      "next_focus": "const_contracts.c needs const-qualified pointer wrappers next."
    },
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "const_contracts.c",
      "type": "code",
      "file_path": "const_contracts.c",
      "content": "#include <stddef.h>\n#include <stdbool.h>\n\n/* Provide a const-correct slice over immutable storage so callers can peek at read()-produced buffers without mutating them; implement by bounds-checking the offset/length and recording the exposed length via view_len. */\nconst char *expose_readonly_view(const char *buffer,\n                                 size_t buffer_len,\n                                 size_t offset,\n                                 size_t min_view,\n                                 size_t *view_len)\n{\n    (void)buffer;\n    (void)buffer_len;\n    (void)offset;\n    (void)min_view;\n    (void)view_len;\n\n    return NULL;\n}\n\n/* Copy an ASCII configuration token into a mutable buffer while honoring const inputs, truncating safely, and always terminating with '\\'0'. */\nsize_t set_config_buffer(char *restrict dst,\n                         size_t dst_len,\n                         const char *restrict value)\n{\n    (void)dst;\n    (void)dst_len;\n    (void)value;\n\n    return 0;\n}\n\n/* Convert an erased pointer from POSIX APIs back to a mutable view only when the original allocation was non-const; otherwise return NULL to preserve const-correctness guarantees. */\nvoid *mutable_from_void(void *payload,\n                        bool original_was_const)\n{\n    (void)payload;\n    (void)original_was_const;\n\n    return NULL;\n}\n",
      "is_complete": false,
      "next_focus": "pointer_ops.h prototypes for pointer arithmetic helpers still need stubs."
    }
  ],
  "next_focus": "pointer_ops.h prototypes for pointer arithmetic helpers still need stubs."
}