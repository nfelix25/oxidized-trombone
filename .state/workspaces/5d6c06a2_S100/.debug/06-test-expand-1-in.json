{
  "schema_version": "context_packet_v1",
  "packet_id": "b5d43ca8-e78a-4d42-967b-e5b0cd1e7aa1",
  "timestamp_utc": "2026-02-24T18:52:32.408Z",
  "role": "test-expand",
  "task_type": "test_expand",
  "learner_profile": {
    "masteryLevel": 0
  },
  "curriculum_context": {
    "node_id": "S100",
    "depth_target": "D1"
  },
  "misconception_context": {
    "top_tags": []
  },
  "attempt_context": null,
  "evidence_context": null,
  "policy_context": {
    "allow_reveal": false
  },
  "memory_context": {},
  "scaffold_context": {
    "scaffold_id": "scaf_S100_vars_types_mut",
    "exercise_description": "Design a multi-file Rust mini-lab where learners tame smart-home readings using careful binding declarations, exploring mutability, constants, type inference, and shadowing with numeric, boolean, character, tuple, and unit values in preparation for richer stateful programs.",
    "lesson_plan": {
      "section_intents": [
        "Hook: contrast immutable vs mutable binding in a playful thermostat example",
        "Concept: introduce `let`, `mut`, and `const` syntax plus type inference defaults",
        "Worked Example 1: step through creating typed numeric bindings (`i32`, `u64`, `f64`) and observing implicit conversions",
        "Worked Example 2: model booleans, chars, and tuples through a mini sensor payload structuring task",
        "Pitfall Focus: uncover errors from mixing mutable borrows and reassignment plus misunderstanding unit type",
        "Comparison: analyze shadowing vs mutation trade-offs for configuration toggles",
        "Bridge: foreshadow how disciplined bindings support upcoming control-flow decisions and ownership rules"
      ]
    },
    "starter_plan": {
      "file_intents": [
        "src/bindings.rs: stubs `init_temperature`, `toggle_power_state`, `freeze_level`, `shadow_demo`, `const_identifier`, `unit_logger`",
        "src/types.rs: stubs `max_u64_sensor`, `avg_f64_readings`, `char_from_code`, `tuple_swap`, `bool_gate`"
      ]
    },
    "test_plan": {
      "case_intents": [
        "bindings::init_temperature returns immutable `i32` default and rejects mutation attempts",
        "bindings::toggle_power_state flips a mutable `bool` binding and persists state change",
        "bindings::freeze_level uses `const` with explicit type and prevents reassignment",
        "bindings::shadow_demo shows value change via shadowing without mutating original binding",
        "bindings::const_identifier enforces uppercase naming and compile-time literal assignment",
        "bindings::unit_logger emits `()` and proves side-effect-only execution",
        "types::max_u64_sensor clamps to `u64::MAX` when overflow would occur",
        "types::avg_f64_readings keeps double precision and handles empty slice via `Option`",
        "types::char_from_code safely converts `u32` to `char` or errors on invalid scalar value",
        "types::tuple_swap swaps `(i32, bool)` elements without mutation using pattern matching"
      ]
    }
  },
  "prior_loop_sections": [
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "section_bindings",
      "type": "file",
      "file_path": "bindings.rs",
      "content": "#![allow(dead_code)]\n\n/// Demonstrates that `let` bindings are immutable by default and should return a preset `i32`.\n/// Implement by declaring an immutable indoor temperature and handing the value back untouched.\npub fn init_temperature() -> i32 {\n    // TODO: Declare an immutable reading and return it.\n    todo!()\n}\n\n/// Highlights the `mut` keyword by letting a boolean binding flip states before being returned.\n/// Implement by toggling the provided power flag and persisting the mutated result.\npub fn toggle_power_state(current: bool) -> bool {\n    // TODO: Copy the flag into a mutable binding, toggle it, and return the outcome.\n    todo!()\n}\n\n/// Reinforces `const` declarations with explicit types for freezing thresholds.\n/// Implement by defining a constant freeze level and making the function expose it.\npub fn freeze_level() -> i32 {\n    // TODO: Declare a typed const inside or outside the function and surface its value.\n    todo!()\n}\n\n/// Explores shadowing by reusing the same identifier for transformed numeric readings.\n/// Implement by deriving successive bindings that change the value without mutating the original.\npub fn shadow_demo(reading: i32) -> i32 {\n    // TODO: Shadow the input with new bindings and return the final value.\n    todo!()\n}\n\n/// Emphasizes uppercase `const` naming and compile-time literals for identifiers.\n/// Implement by exposing a string slice tied to a `const` that follows style guidelines.\npub fn const_identifier() -> &'static str {\n    // TODO: Define the const identifier literal and return it here.\n    todo!()\n}\n\n/// Showcases the unit type by logging side effects while returning `()` explicitly.\n/// Implement by emitting diagnostics or counters and finishing with the unit value.\npub fn unit_logger(message: &str) {\n    // TODO: Perform some observable action, then end with () implicitly or explicitly.\n    todo!()\n}\n",
      "is_complete": false,
      "next_focus": "Add the types.rs stubs covering numeric, boolean, char, and tuple patterns."
    },
    {
      "schema_version": "starter_section_v1",
      "role": "starter-expand",
      "section_id": "section_types",
      "type": "file",
      "file_path": "types.rs",
      "content": "#![allow(dead_code)]\n\n/// Demonstrates explicit numeric typing by capping wide readings into a `u64` domain.\n/// Implement by finding the largest `u128` in `candidates` and clamping it to `u64::MAX` when necessary.\npub fn max_u64_sensor(candidates: &[u128]) -> u64 {\n    // TODO: Determine the maximum reading and prevent overflow beyond `u64::MAX`.\n    todo!()\n}\n\n/// Highlights floating-point type inference and the Option pattern for potentially missing data.\n/// Implement by returning `Some` average of `values` as an `f64` or `None` when the slice is empty.\npub fn avg_f64_readings(values: &[f64]) -> Option<f64> {\n    // TODO: Sum with `f64` precision, divide by the count, and wrap the result in `Option`.\n    todo!()\n}\n\n/// Covers `char` construction from scalar values while validating Unicode boundaries.\n/// Implement by converting `code` to a `char` via `char::from_u32` and bubbling up invalid inputs.\npub fn char_from_code(code: u32) -> Option<char> {\n    // TODO: Attempt the conversion and return `None` when the scalar value is disallowed.\n    todo!()\n}\n\n/// Reinforces tuple destructuring and reconstruction without mutating the original binding.\n/// Implement by pattern matching `(i32, bool)` and returning `(bool, i32)` in swapped order.\npub fn tuple_swap(pair: (i32, bool)) -> (bool, i32) {\n    // TODO: Use pattern matching to reorder the elements immutably.\n    todo!()\n}\n\n/// Explores boolean gate composition with strongly typed operands and return values.\n/// Implement by combining `lhs` and `rhs` using a chosen gate (e.g., AND/OR) and exposing the resulting `bool`.\npub fn bool_gate(lhs: bool, rhs: bool) -> bool {\n    // TODO: Pick a gate operation, document it, and return the evaluated boolean.\n    todo!()\n}\n",
      "is_complete": true,
      "next_focus": "Starter files complete; await further scaffolding instructions."
    }
  ],
  "current_sections": []
}