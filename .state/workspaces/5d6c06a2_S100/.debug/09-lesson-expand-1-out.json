{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "section_hook",
    "type": "concept",
    "content": "You walk into our smart-home lab and the thermostat greets you with two numbers: the promised comfort goal and the fickle air it actually feels. In Rust terms, those two experiences map to two different bindings. The target temperature is announced once and treated as law: `let setpoint = 72;`. Because `let` without extras is immutable, the compiler guarantees no later line will nudge that number—perfect for a safety-critical promise. The air sensor, however, needs wiggle room as vents open and close. We capture that with a mutable binding: \n```rust\nlet mut current = 76; // noisy reading that must adapt\ncurrent -= 2; // blower kicks in\nprintln!(\"Setpoint: {setpoint}°F, Current: {current}°F\");\n```\nTry swapping the keywords—making `setpoint` mutable or removing `mut` from `current`—and Rust immediately objects, reminding us exactly which values may drift. This playful thermostat contrast sets the tone for the lab: identify which readings must never change, mark them immutable, and reserve `mut` for the rare spots where state truly evolves. Once you feel that tension, the rest of Rust’s binding rules click into place.",
    "is_complete": false,
    "next_focus": "Introduce `let`, `mut`, and `const` syntax along with type inference defaults."
  }
}