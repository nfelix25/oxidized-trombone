{
  "accepted": true,
  "schemaName": "lesson_section_v1",
  "payload": {
    "schema_version": "lesson_section_v1",
    "role": "lesson-expand",
    "section_id": "section_numeric_bindings",
    "type": "worked_example",
    "content": "Let’s wire up a single routine that mixes `i32`, `u64`, and `f64` while watching Rust’s inference and conversion rules at play.\n```rust\nfn numeric_payload(samples: &[i32]) -> (i32, u64, f64) {\n    let indoor_celsius: i32 = samples.iter().copied().sum();\n    let mut fan_cycles = 0_u64;            // suffix forces u64\n    for _ in 0..3 {\n        fan_cycles += u64::from(samples.len() as u32);\n    }\n\n    let indoor_fahrenheit = indoor_celsius as f64 * 1.8 + 32.0; // promotion to f64 happens before math\n    (indoor_celsius, fan_cycles, indoor_fahrenheit)\n}\n```\nWalkthrough:\n- `indoor_celsius` uses an explicit annotation so we can guarantee 32-bit signed math even though the iterator sum would have inferred it for us.\n- `fan_cycles` showcases literal suffixes instead of annotations; writing `0_u64` makes the type crystal clear, and each loop iteration converts the slice length through `as u32` and finally `u64::from` to avoid accidental narrowing.\n- The Fahrenheit conversion highlights that casting from `i32` to `f64` is implicit inside the `as` expression, after which floating-point literals (`1.8`, `32.0`) ensure the compiler keeps the whole expression in double precision.\nExperiment by removing the casts: the compiler immediately refuses to add `u64` and `usize`, or to multiply integers by `1.8`, reinforcing how explicit conversions keep your bindings honest.",
    "is_complete": false,
    "next_focus": "Worked Example 2: model booleans, chars, and tuples through a mini sensor payload structuring task"
  }
}